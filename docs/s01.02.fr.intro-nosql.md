# NoSQL et bases de donn√©es graphes

Ce cours aborde deux types sp√©cifiques de bases de donn√©es NoSQL
- MongoDB, une base de donn√©es - document
- Neo4j, une graph database.
- et nous verrons aussi les vector store qui sont important pour l'IA et le NLP


## Qu'est-ce qu'une base de donn√©es ?

<img src="./../img/memes/what-is-a-database.png" width='50%' style='display: block; margin: auto; ' alt= "what is a database asks Sheldon?">

On entends parfois le mot base de donn√©es pour d√©signer un fichier Excel.


Comment peut-on mettre quelque chose d'aussi simple qu'un fichier CSV ou Excel au m√™me niveau que ces merveilles d'ing√©nierie que sont PostgreSQL, Weaviate, MongoDB, Neo4j, Redis, MySQL etc...

J'ai donc demand√© √† mon ami GPT-4 de me donner une d√©finition d'une base de donn√©es :

> En termes simples :
  "Une base de donn√©es est comme un carnet intelligent ou un syst√®me de classement qui vous aide √† garder une trace de nombreuses informations et √† trouver exactement ce dont vous avez besoin en un rien de temps."

ce qui inclut d√©finitivement les fichiers CSV, les fichiers Excel, les fichiers JSON, les fichiers XML et tant d'autres formats simples bas√©s sur un seul fichier.

Si nous cherchons la d√©finition d'une base de donn√©es dans une source de connaissance plus classique et v√©n√©rable, comme l'[Encyclop√©die Britannica](https://www.britannica.com/technology/database), nous obtenons :

> base de donn√©es, toute collection de donn√©es ou d'informations sp√©cialement organis√©e pour une recherche rapide par ordinateur. Les databases sont structur√©es pour faciliter le storage, l'extraction, la modification et la suppression des donn√©es.

Voir aussi l'article Base de donn√©es sur [Wikipedia](https://fr.wikipedia.org/wiki/Base_de_donn%C3%A9es).

Tr√®s int√©ressant. Nous ne parlons plus seulement de trouver rapidement l'information (la partie **recherche**) mais aussi de :

- stockage
- modification
- suppression
- Administration.

C'est l√† qu'un simple fichier de type tableur ne correspond plus √† l'objectif.

## Ce que l'on attend d'un SGBD

Un syst√®me de gestion de base de donn√©es (SGBD) se distingue d'un simple spreadsheet par plusieurs fonctionnalit√©s essentielles.

| Feature                        | Description                                                                                                     | Excel | SGBD |
| ------------------------------ | --------------------------------------------------------------------------------------------------------------- | ----- | ---- |
| **Data Storage and Retrieval** | Stocke les donn√©es de mani√®re organis√©e et les r√©cup√®re selon les besoins.                                      | ‚úÖ     | ‚úÖ    |
| **Data Manipulation**          | Permet d'ajouter, modifier ou supprimer des donn√©es.                                                            | ‚úÖ     | ‚úÖ    |
| **Data Querying**              | Permet de poser des questions complexes (requ√™tes) sur les donn√©es.                                             | ‚úîÔ∏è     | ‚úÖ    |
| **Data Organization**          | Structure les donn√©es dans des formats comme des tables, documents ou graphes pour faciliter la gestion.        | ‚úÖ     | ‚úÖ    |
| **Data Sharing**               | Permet √† plusieurs utilisateurs ou applications d'utiliser la base de donn√©es simultan√©ment.                    | ‚úÖ     | ‚úÖ    |
| **Data Security**              | Prot√®ge les donn√©es contre les acc√®s non autoris√©s ou la corruption.                                            | ‚úîÔ∏è     | ‚úÖ    |
| **Concurrency Control**        | G√®re plusieurs utilisateurs modifiant les donn√©es en m√™me temps sans conflits.                                  |       | ‚úÖ    |
| **Backup and Recovery**        | Garantit que les donn√©es ne sont pas perdues et peuvent √™tre restaur√©es en cas de d√©faillance.                  | ‚úîÔ∏è     | ‚úÖ    |
| **Data Integrity**             | Garantit que les donn√©es restent pr√©cises, coh√©rentes et fiables.                                               |       | ‚úÖ    |
| **Performance Optimization**   | Fournit des outils pour optimiser la vitesse et l'efficacit√© des retrievals et updates de donn√©es.              |       | ‚úÖ    |
| **Support for Transactions**   | Garantit qu'un groupe d'op√©rations (transactions) est compl√©t√© enti√®rement ou pas du tout. <br> ACID compliance |       | ‚úÖ    |

## Un br√®ve histoire des bases de donn√©es


<img src="./../img/evolution-of-databases.png" width='80%' style='display: block; margin: auto; padding-bottom: 30px;' alt= "Evolution of database from 1970 to 2024">

### 1970s - Le d√©but de l'√®re relationnelle

- **1970** : **[Edgar Codd](https://en.wikipedia.org/wiki/Edgar_F._Codd)** publie "[A Relational Model of Data for Large Shared Data Banks](https://github.com/SkatAI/epita-mongodb/blob/master/pdfs/codd.pdf)"
- **1974** : **IBM** d√©veloppe System R, le premier prototype de DBMS SQL
- **1979** : **Oracle** lance la premi√®re impl√©mentation SQL commerciale

### 1980s - La domination du relationnel

- **1989** : D√©but du d√©veloppement de Postgres (maintenant [PostgreSQL](https://www.postgresql.org/)) √† UC Berkeley
  - üéñÔ∏èüéñÔ∏èüéñÔ∏è la base de donn√©es SQL de r√©f√©rence.
  - maintenant peut g√©rer le no-sql & vector,
  - nombreuses extensions (http, postgis, ...).
  - performances exceptionnelles.
  - et OPEN SOURCE (gratuit, efficace et s√©curis√©).

### 1990s - La vague orient√©e objet

- **1991** : Les bases de donn√©es Object-Oriented gagnent en attention. <br> La plupart des OODBs des ann√©es 90 ne sont plus utilis√©es. Mais elles ont influenc√© l'√©volution des databases SQL et NoSQL.

- **1995** : MySQL est publi√© en open source

### 2000s - Le d√©but de la r√©volution NoSQL

- 2 papiers importants qui posent les bases des syst√®mes NoSQL : [BigTable paper](https://research.google.com/archive/bigtable-osdi06.pdf) (Google, 2004) et [Dynamo paper](https://www.amazon.science/publications/dynamo-amazons-highly-available-key-value-store) (Amazon, 2007)

Et en **2009**, 2 nouvelles databases sont lanc√©es :

- ü•≠ü•≠ü•≠ MongoDB
- üéâüéâüéâ Neo4j

Tadaaah !


#### Pourquoi √† ce moment-l√† ?

L'essor du world wide web (myspace - 2003 üòç, youtube - 2005) et l'augmentation massive de l'√©chelle des applications de plusieurs ordres de grandeur.

Soudainement, nous avons des millions de personnes qui tentent simultan√©ment d'acc√©der et de modifier des Terabytes de donn√©es en quelques millisecondes.

Les databases relationnelles ne peuvent pas suivre l'√©chelle des applications, la nature chaotique des donn√©es non structur√©es et les exigences de vitesse.

La promesse du NoSQL est le **volume et la vitesse**.

### 2010s - Le NoSQL arrive √† maturit√© & Sp√©cialisation - Big Data et Databases Sp√©cialis√©es

- **Big Data Databases** : Des syst√®mes comme **Apache Hadoop** (2006) et **Apache Spark** (2009) ont permis le traitement de donn√©es √† tr√®s grande √©chelle.
- Les **Graph Databases** gagnent en popularit√© avec des cas d'usage comme la d√©tection de fraude, les knowledge graphs, et la gestion de la cha√Æne d'approvisionnement. Neo4j et Amazon Neptune deviennent des acteurs cl√©s.
- **Time-Series Databases (ex : InfluxDB, TimescaleDB)** : con√ßues pour les syst√®mes de monitoring : IoT, logs, ...
- **Cloud Databases** : services manag√©s comme Amazon **RDS**, Google **BigQuery**, ou **Snowflake**

et entre-temps, en 2013, les containers **Docker** r√©volutionnent le d√©ploiement des databases

### **2020s : IA, Vector Databases, et Besoins Temps R√©el**

- **Vector Databases** üå∂Ô∏èüå∂Ô∏èüå∂Ô∏è (ex : Pinecone, Weaviate, Qdrant, Milvus, Faiss, ...) :
  - G√®rent les vector embeddings de haute dimension utilis√©s dans les applications AI/ML

- et aussi :
  - üå∂Ô∏èüå∂Ô∏èüå∂Ô∏è **Graph + AI** : üå∂Ô∏èüå∂Ô∏èüå∂Ô∏è knowledge graphs et LLMs.
  - Multi-Model Databases qui supportent plusieurs mod√®les de donn√©es (document, graph, key-value) dans un seul syst√®me.
  - Real-Time Analytics : optimis√©s pour le streaming de donn√©es en temps r√©el et l'analytique.
  - Serverless Databases

### Tendances Actuelles (2025)

La vector search est en plein essor. Les capacit√©s de vector search sont int√©gr√©es dans la plupart des DBMS existants, y compris PostgreSQL, MongoDB et Neo4j.

![√©volution des databases](/img/epita-atabase-evolution-2024-11-21-062329.png)

### En Bref

- 1989 : Lancement de PostgreSQL
- 2009 : Lancement de MongoDB et Neo4j
- 2024 : les vector databases sont en vogue tandis que les databases plus anciennes int√®grent la vector search

## Cat√©gories principales de databases aujourd'hui

Nous avons de nombreuses bases de donn√©es parmi lesquelles choisir. Tout d√©pend de l'√©chelle, de la nature de l'application, du budget, etc.

| Type de base de donn√©es   | Objectif                                   | Exemples                  | Application                                |
| ------------------------- | ------------------------------------------ | ------------------------- | ------------------------------------------ |
| **Relational - SQL**      | Schema fixe                                | PostgreSQL, MySQL, Oracle | Transactions, normalisation                |
| **Document Stores**       | Schema flexible, documents type JSON       | MongoDB, CouchDB          | Applications web, gestion de contenu       |
| **Graph Databases**       | Donn√©es centr√©es sur les relations         | Neo4j, ArangoDB           | R√©seaux sociaux, moteurs de recommandation |
| **Key-Value Stores**      | Recherches simples et rapides              | Redis, DynamoDB           | Caching, gestion des sessions              |
| **Vector Databases**      | Recherche par similarit√©, AI embeddings    | Pinecone, Weaviate        | Applications IA, recherche s√©mantique      |
| **Column-Family Stores**  | Donn√©es colonnes larges, haute scalabilit√© | Cassandra, HBase          | Time-series, applications big data         |
| **Time-Series Databases** | Donn√©es ordonn√©es dans le temps            | InfluxDB, TimescaleDB     | IoT, syst√®mes de monitoring                |


### √âcosyst√®me

Consultez le classement de toutes les bases de donn√©es sur <https://db-engines.com/en/ranking>

Les tendances : <https://db-engines.com/en/ranking_trend>

![tendances des base de donn√©ess](./../img/databases-trends.png)

De tr√®s nombreux acteurs :

![Carte du march√© des Databases 2024](./../img/Database-Market-Map-1.png)

source : <https://www.generativevalue.com/p/a-primer-on-databases>

Voir aussi cette carte interactive qui rescence tous les acteurs en 2023.

<https://mad.firstmark.com/>

Prenons du recul et comparons une base de donn√©es relationnelle SQL et une base de donn√©es NoSQL.

## SQL

Une base de donn√©es relationnelle SQL (et variations de SQL):

- utilise un **schema** pr√©d√©fini : la structure des donn√©es (colonnes, types de donn√©es, etc.) est fixe.
- les bdd relationelles sont efficaces pour les requetes complexes, pour les transactions et pour assurer la coh√©rence des donn√©es (conformit√© ACID).

Une **base de donn√©es relationnelle** peut √™tre compar√©e √† une collection de spreadsheets bien organis√©s (tables) o√π chaque colonne est d√©finie, et les tables sont interconnect√©es.

Les tables ont des colonnes et des lignes de donn√©es. Chaque table a une cl√© unique appel√©e **primary key**.

La conception du schema repose sur le concept de normalisation / d√©normalisation.
Dans une bdd normalis√©em une information n'existe que dans une seule table. Une bdd normalis√©e valide une s√©rie de r√®gles appel√©es NF1, NF2, ...

> Concept important de **Normalisation** : une information n'existe qu'√† un seul endroit et un seul.

### Hi√©rarchie d'une base de donn√©es SQL :

- Une cl√© primaire unique pour chaque √©l√©ment d'une table donn√©e
- Une **foreign key** lie une table √† une autre table
- Un **row** contient la valeur d'une _entity_
- Un **column** est un **attribute** ou une propri√©t√© de l'_entity_
- Un **table** contient toutes les entities regroup√©es dans une structure fixe de colonnes

Les databases SQL = rigides, contr√¥l√©es, donn√©es coh√©rentes, stables.
Peuvent √™tre complexes.

## NoSQL

Une **base de donn√©es non-relationnelle** est un syst√®me de dossiers flexible o√π vous pouvez stocker des √©l√©ments
- de diff√©rentes formes
- sans r√®gles strictes.

Les bases de donn√©es NoSQL utilisent des mod√®les de donn√©es non relationnels, tels que :

- Cl√©-valeur (ex : Redis, DynamoDB)
- Document (ex : MongoDB, Couchbase)
- Colonnes larges (ex : Cassandra, HBase)
- Graphes (ex : Neo4j)

Les Bdd NoSQl recoupent des syst√®mes d'organisations des donn√©es tr√®s diff√©rents.
Une representation des donn√©es sur la base d'un graphe de donn√©es est tr√®s diff√©rente d'une representation en mode document de type JSON ou la variabilit√© ddu contenu est sans limite.


Dans tous les cas on parle de **schema flexible** avec des donn√©es non structur√©es ou semi-structur√©es.
La flexiibilit√© du sch√©ma permet d'ajouter de nouveaux types de donn√©es ou de modifier la structure des donn√©es sans n√©cessiter de migrations complexes.


Les bdd NoSQL sont id√©ales pour
- haute scalabilit√©: capacit√© d'un syst√®me √† g√©rer une augmentation significative de la charge de travail (donn√©es, utilisateurs, transactions) tout en maintenant des performances optimales.
  - Scalabilit√© verticale  : augmenter les ressources d'un seul serveur (CPU, RAM, disque dur) pour g√©rer plus de charge.
  - Scalabilit√© horizontale :  ajouter des serveurs suppl√©mentaires au cluster pour r√©partir la charge.
- R√©plication et partitionnement: les donn√©es sont r√©parties sur plusieurs serveurs ou n≈ìuds (sharding pour MongoDB)
  - R√©plication : Les donn√©es sont copi√©es sur plusieurs serveurs pour assurer la disponibilit√© et la r√©silience en cas de d√©faillance d'un serveur.
  - Partitionnement (sharding) : Les donn√©es sont divis√©es en fragments (shards) et r√©parties sur plusieurs serveurs.

### Cmoparraison erplication et partitionnement

Bien que les bases de donn√©es SQL et NoSQL prennent en charge la r√©plication et le sharding, il existe des diff√©rences cl√©s dans leur mise en ≈ìuvre et leur utilisation :

| Aspect                  | Bases de donn√©es SQL                                                                                   | Bases de donn√©es NoSQL                                                                           |
| ----------------------- | ------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------ |
| R√©plication             | Souvent synchrone ou asynchrone, avec une forte coh√©rence possible.                                    | Souvent asynchrone, avec _consistance √©ventuelle_ (eventual consistency).                        |
| Sharding                | Plus complexe √† mettre en ≈ìuvre, n√©cessite des outils externes ou des configurations manuelles.        | Int√©gr√© nativement dans de nombreuses bases de donn√©es NoSQL (ex : MongoDB, Cassandra).          |
| Flexibilit√©             | Moins flexible en raison du sch√©ma rigide et des contraintes ACID.                                     | Tr√®s flexible, adapt√© aux donn√©es non structur√©es et aux mod√®les de donn√©es vari√©s.              |
| Scalabilit√© horizontale | Possible, mais souvent plus difficile √† g√©rer en raison des jointures et des transactions distribu√©es. | Con√ßu d√®s le d√©part pour la scalabilit√© horizontale, avec des architectures distribu√©es natives. |


## Terminologie


Dans une bdd NoSQL de type document comme MongoDB

- Une **collection** est un ensemble de **documents**.
- Un document est une combinaison de keys : values .
- Chaque collection a une cl√© unique (le champ _id)
- Dans un document, vous pouvez avoir des sous-documents imbriqu√©s. Par exemple: Une personne peut avoir plusieurs t√©l√©phones, adresses email, emplois, ...

Tous les documents d'une collection sont **similaires en structure** mais n'ont pas besoin d'√™tre exactement identiques.

Il n'y a pas de concept de normalisation.

### Hi√©rarchie de MongoDB - base de donn√©es NoSQL - MongoDB

- Une **base de donn√©e** contient des **Collections**
- Une **collection** contient tous les **documents** -> table
- Un **document** est l'entit√© qui contient les donn√©es -> enregistrement
- Un sous-document (imbriqu√©) est un document **√† l'int√©rieur** d'un document parent
- Un **field / champs** est un attribut ou une propri√©t√© du document -> colonne



MongoDB - SQL :

- Un `document` est un enregistrement
- Une `Collection` est une table
- Un `Field` est une colonne

| MongoDB           | SQL base de donn√©es |
| ----------------- | ------------------- |
| base de donn√©es   | base de donn√©es     |
| Collection        | Table               |
| Document          | Record/Row          |
| Field             | Column              |
| Embedded Document | Foreign Key         |
| `_id`             | Primary Key         |
| `$lookup`         | JOIN                |

Un `index` reste un `index`


## Schema-less ou schema dynamique

Dans quelles situations les donn√©es sont-elles si dynamiques qu'il nous faut un type sp√©cial de base de donn√©es ?

L'exemple le plus courant d'application NoSQL est celui d'un r√©seau social.

- profils utilisateurs
- les posts contiennent toutes sortes de contenu
- timeline, followers, etc

### Yuka et les produits alimentaires

Prenons l'exemple d'une start-up comme [Yuka](https://yuka.io/en/)

![Yuka](./../img/yuka-screenshot.png)

Selon leurs propres mots : _Yuka d√©chiffre les √©tiquettes des produits et analyse l'impact sur la sant√© des produits alimentaires et cosm√©tiques._

Sa base de donn√©e sous-jacente est la [open food facts base de donn√©es](https://world.openfoodfacts.org/), une base de donn√©e de produits alimentaires faite par tous, pour tous, avec plus de 3,5 millions de produits alimentaires.

Regardez par exemple les informations pour [Nutella](https://uk.openfoodfacts.org/product/3017620422003/nutella) et celles pour... [Baguette](https://world.openfoodfacts.org/product/3250393046940/baguette-constance-cereales-250g-la-campaniere)

Voir aussi cet article qui explore le dataset avec python pandas : <https://medium.com/@achrafelkhanjari99/a-deep-dive-into-the-open-food-facts-dataset-56259b162ac5> (disponible en pdf dans la repo Github)

Avec autant de produits, les informations disponibles et les informations associ√©es (Packaging, Impact Carbone) ainsi que la diversit√© des r√©glementations (UE, US, UK, ... etc) varient constamment.

Les donn√©es sont constamment mises √† jour alors qu'il faut conserver l'historique des changements et des nouveaut√©s.

- de nouvelles donn√©es deviennent disponibles au fur et √† mesure que les acteurs mettent en place la collecte de donn√©es. Pensez tra√ßabilit√©, s√©curit√©, etc
- les nouvelles r√©glementations imposent plus de donn√©es
- l'actualit√©, les tendances sociales et les centres d'int√©r√™t changent rapidement (sans gluten, thon et mercure, pesticides, ...)

Vous commencez donc votre base de donn√©es avec un schema simple qui inclut :

- nom, d√©finition, image, description
- valeurs nutritionnelles
- ingr√©dients

Mais le schema devient de plus en plus complexe √† mesure qu'√©voluent les donn√©es , les produits et les services de l'entreprise.

#### Nutriscore

Prenons par exemple, le label Nutriscore :

<img src="./../img/nutri-score-f_1200x800.jpg" width='50%' style='display: block; margin: auto; padding-bottom: 30px;' alt= "Nutriscore">

Le [Nutriscore](https://nutriscore.blog/2022/08/04/report-of-the-european-scientific-committee-in-charge-of-updating-the-nutri-score-changes-to-the-algorithm-for-solid-foods/) a r√©cemment √©volu√© avec une nouvelle version plus stricte. Vous avez donc besoin des nouveaux labels Nutriscore tout en gardant l'ancien car tous les produits n'impl√©mentent pas le nouveau Nutriscore. Certaines entreprises ont m√™me compl√®tement abandonn√© l'√©tiquetage.

Vous avez commenc√© avec une table Nutriscore dans une base de donn√©es SQL :

```sql
product_id: key
nutriscore_label : array[A,B, .., E]
```

donc votre table Nutriscore n√©cessite une nouvelle colonne :

```sql
product_id: key
nutriscore_label: array[A,B, .., E]
nutriscore_new_label: array[A,B, .., E]
```

Cependant, la plupart des produits n'ont pas encore de nouveau label nutriscore.

Et vous vous retrouvez avec beaucoup de null values dans cette colonne `nutriscore_new_label` et les null values sont √† √©viter üëπüëπüëπ.

![NULL values headache](./../img/memes/null-values-headache.png)

Vous pouvez aussi normaliser la table et introduire une colonne version du Nutriscore pour aider avec les Null values.

```sql
product_id: key
nutriscore_label: array[A,B, .., E]
nutriscore_version: Int
```

Dans les deux cas, vous devez changer toutes vos requetes SQL  dans votre base de code .

Douleur, soucis, migra√Ænes, bugs  et co√ªts suppl√©mentaires ÔºÑÔºÑÔºÑ.

## Introduction √† la Flexibilit√© du sch√©ma

La **Flexibilit√© du sch√©ma** dans MongoDB et d'autres base de donn√©ess NoSQL fait r√©f√©rence √† la capacit√© de stocker des donn√©es sans n√©cessiter un schema pr√©d√©fini. Cela signifie que les documents d'une m√™me collection peuvent avoir diff√©rents champs / attributs, structures et types de donn√©es.

La Flexibilit√© du sch√©ma aide √† g√©rer les **unknown unknowns** dans un monde qui change rapidement.

### Pr√©sence et type de donn√©es

Dans MongoDB : Vous pouvez simplement ajouter un nouvel √©l√©ment Nutriscore aux produits alimentaires :

Pas de Nutriscore

```json
{
  "product_id": 198273,
  "name": "Chocapic",
}
```

Le Nutriscore est ajout√©, il suffit d'ajouter un field au document du produit

```json
{
  "product_id": 198273,
  "name": "Chocapic",
  "Nutriscore": "C"
}
```

Une nouvelle version du Nutriscore arrive, il suffit d'ajouter le label Nutriscore comme un dictionary avec les versions comme keys :

```json
{
  "product_id": 198273,
  "name": "Chocapic",
  "Nutriscore": {
    "v1": C,
    "v2": D,
  }
}
```

Plusieurs repr√©sentations peuvent donc **coexister** dans la m√™me base de donn√©es :

- Pas de nutriscore
- Un seul nutriscore comme _string_
- Un dictionary nutriscore comme document nested / embedded

### Donn√©es imbriqu√©es

- Pourr √™tre efficace, une base de donn√©e SQL doit √™tre normalis√©e. Pour les donn√©es complexes, on risque de se retrouver avec beaucoup de tables.
- MongoDB permet d'**imbriquer** les donn√©es de fa√ßon naturelle

Un bon exemple est celui de l'adresse d'une personne

On peut avoir dans la m√™me base, des personnes qui n'ont pas d'adresse, une adresse ou plusieurs. Et ces plusieurs adresses ont des roles diff√©rents : r√©sidence principale, secondaire, etc ....

Si on utilise un format JSON pour representer ces 3 cas, on a naturellement

```json
// Une personne sans adresse enregistr√©e
{
    "_id": "1",
    "name": "Anita Sharma",
    "age": 29,
    "email": "anita.sharma@example.com"
}

// Une personne avec une seule adresse comme simple dictionaire
{
    "_id": "2",
    "name": "Rahul Verma",
    "age": 42,
    "email": "rahul.verma@example.com",
    "address": {
        "type": "home",
        "street": "12 MG Road",
        "locality": "Indiranagar",
        "city": "Bengaluru",
        "state": "Karnataka",
        "pincode": "560038",
        "country": "India"
    }
}

// Une personne avec plusieurs adresses comme liste de dictionaires
{
    "_id": "3",
    "name": "Priya Singh",
    "age": 35,
    "email": "priya.singh@example.com",
    "addresses": [
        {
            "type": "home",
            "street": "45/2 Lajpat Nagar",
            "locality": "Central Market",
            "city": "New Delhi",
            "state": "Delhi",
            "pincode": "110024",
            "country": "India"
        },
        {
            "type": "work",
            "street": "4th Floor, Tower B",
            "locality": "DLF Cyber City",
            "city": "Gurugram",
            "state": "Haryana",
            "pincode": "122002",
            "country": "India"
        }
    ]
}
```


En SQL, il faudrait avoir une table addresse et une relation many to many entre la table personne et la table personne, ddonc une table intermediaire de jointure.


### Cons√©quences de la flexibilit√© du sch√©ma

La flexibilit√© du sch√©ma impacte chaque √©tape du cycle de vie d'une base de donn√©es

- **Design** : sans r√®gles, tout devient possible. Les choix de conception sont dict√©s par l'application. La fa√ßon dont les donn√©es sont _consomm√©es_ dicte la structure des donn√©es dans la base de donn√©es.
- **Development** : avec un schema flexible, les changements peuvent √™tre impl√©ment√©s plus rapidement.
- **Maintenance** : l'inconv√©nient est la n√©cessit√© de g√©rer une organisation et des types de donn√©es historiques

Une prudence suppl√©mentaire est n√©cessaire pour √©viter le chaos et les **data inconsistencies**. La performance des requetes peut √™tre affect√©e si les changements dans la structure des donn√©es conduisent √† un indexing inefficace ou incoh√©rent.

Avec les databases NoSQL, le co√ªt de l'impl√©mentation des changements dans la nature des donn√©es est d√©plac√© de la base de donn√©es vers le niveau applicatif.

Cependant, des inconsistencies dans la base de donn√©es peuvent toujours survenir si plusieurs applications interagissent diff√©remment avec la m√™me base de donn√©es.

> En bref, la flexibilit√© du sch√©ma doit √™tre utilis√©e avec pr√©caution et uniquement lorsque c'est utile et justifi√©.

## Quand choisir NoSQL (base de donn√©es - document) plut√¥t que SQL ?

Alors quand est-ce qu'une base de donn√©es document NoSQL est un meilleur choix que SQL ?

- Vos donn√©es correspondent naturellement √† une structure de **documents** plut√¥t qu'√† des tables strictes
  - Vous voulez stocker les donn√©es li√©es ensemble plut√¥t que de les r√©partir dans des tables pour acc√©l√©rer la r√©cup√©ration d'information: les requ√™tes sont plus simples, il y a moins de jointures, et simplicit√© du code.

- It√©ration Rapide : Votre schema doit √©voluer rapidement et vous privil√©giez la vitesse de d√©veloppement √† la stricte coh√©rence des donn√©es
  - Applications et exigences de donn√©es qui changent rapidement
  - Startups en phase initiale o√π le mod√®le de donn√©es n'est pas encore pleinement compris

- √©galement : A/B testing de diff√©rentes fonctionnalit√©s qui peuvent n√©cessiter diff√©rentes structures de donn√©es

- Scalabilit√© et Performance
  - Con√ßu pour le **horizontal scaling** avec support int√©gr√© du **sharding** (distribution des donn√©es sur plusieurs serveurs).
  - Adapt√© √† la gestion d'applications √† grande √©chelle, haut d√©bit et g√©ographiquement distribu√©es.

MongoDB scale out, tandis que PostgreSQL scale up.

- Utilise un mod√®le de document flexible de type JSON (BSON), le rendant id√©al pour les donn√©es hi√©rarchiques ou semi-structur√©es.
  - R√©duit le besoin de joins complexes, car les donn√©es li√©es peuvent √™tre embedded dans un seul document.

MongoDB excelle dans :

- Les applications avec des donn√©es non structur√©es ou semi-structur√©es.
- Les charges de travail √† haute v√©locit√© n√©cessitant des changements rapides de schema.
- Les cas d'utilisation n√©cessitant un horizontal scaling dans des environnements distribu√©s.

### Performances

En termes de performances, la comparaison favorise la plupart du temps PostgreSQL par rapport √† MongoDB.
voir [MongoDB Vs PostgreSQL: A comparative study on performance aspects](https://link.springer.com/article/10.1007/s10707-020-00407-w)

Et cet autre article, [MongoDB vs PostgreSQL: Choosing the Best Database for Your Needs](https://www.halfnine.com/blog/post/mongodb-vs-postgresql), le r√©sume bien :

> _MongoDB brille dans les sc√©narios n√©cessitant le d√©veloppement d'applications logicielles qui traitent divers types de donn√©es de mani√®re √©volutive. Il est particuli√®rement adapt√© aux projets qui doivent supporter un d√©veloppement it√©ratif rapide et faciliter la collaboration de nombreuses √©quipes.

Dans [Postgres vs. MongoDB: a Complete Comparison in 2024](https://www.bytebase.com/blog/postgres-vs-mongodb/)

### En bref

- Choisissez MongoDB si votre application a un mod√®le de donn√©es simple et g√®re un tr√®s grand volume de  donn√©es
- Choisissez PostgreSQL si votre application a une logique m√©tier complexe qui repose sur des transactions.

## Qu'en est-il des bases de donn√©es graphes ?

Les bases de donn√©es SQL sont appel√©es bases de donn√©es relationnelles.

Dans une base de donn√©es SQL, la relation entre les tables est explicitement d√©finie par des cl√©s √©trang√®res.

- Product -> Vegetables -> Location, Origin
- Product -> Vegetables -> Organic / not Bio
- Product -> nutrition (sugar, fat etc)
- Product -> Nutriscore labels
- Product -> ConsumeBy

Et l'ERD pour une telle base de donn√©es indique uniquement la cardinalit√© de la relation :

- 1 to 1
- 1 to many

![ERD](./../img/ERD_v03.png)

Quand vous demandez √† un LLM de g√©n√©rer un diagramme pour une base de donn√©es de produits, il ajoute naturellement des informations significatives aux relations entre les tables.

![product veggies schema relation](/img/product-veggies-schema-relation.png)
[Mermaid](https://mermaid.live) diagram

### Relationships

Les bases de donn√©es graphes sont centr√©es sur la _signification_ des **relations** entre entit√©s.

> Dans les bases de donn√©es graphes comme Neo4j, les **relations** sont aussi importantes que les donn√©es elles-m√™mes et sont stock√©es explicitement.

Ces relations ont leurs propres propri√©t√©s et sont stock√©es comme des connexions.

Alors qu'en SQL :

- Les relations sont implicites via des cl√©s √©trang√®res
- Doivent √™tre reconstruites via des JOINs
- Deviennent exponentiellement plus complexes et lentes lorsque vous suivez plusieurs niveaux de connexions

C'est pourquoi Neo4j excelle dans les questions comme :

- "Trouvez tous les amis d'amis qui aiment courir et qui vivent √† Paris"
- "Quel est le chemin le plus court entre la personne A et la personne B ?"
- "Qui sont les personnes les plus influentes dans ce r√©seau ?"

Voici un exemple de graphe de connaissances avec Obsidian

<img src="./../img/obsidian.jpeg" width='90%' style='display: block; margin: auto; ' alt= "Obsidian Knowledge Graph">


## conclusion

Donc les bases de donn√©es SQL, dites relationnelles, sont excellentes pour les structures de donn√©es qui ne changent pas souvent et o√π les relations entre objets sont stables.

Les bases de donn√©es No-SQL comme MongoDB : excellentes quand les sp√©cifications des donn√©es √©voluent rapidement ou ne sont pas d√©finitives, sch√©ma flexible, grande √©chelle

Bases de donn√©es graphes : la relation est cl√©. Ce n'est pas seulement qu'il y a une relation mais aussi quelle est la nature de cette relation.

- NoSQL - Document concerne l'√©volutivit√© et l'√©volution des donn√©es.
- Graph concerne la r√©ponse √† des questions sp√©cifiques, la d√©couverte de diff√©rents types de signification et d'aper√ßus dans les donn√©es.

Dans cette session, vous avez appris :

- RDBS et l'histoire des bases de donn√©es
- Un aper√ßu des diff√©rents types de bases de donn√©es
- Base de donn√©es relationnelle vs non relationnelle
- Sch√©ma flexible dans les bases de donn√©es NoSQL
- Pourquoi et quand choisir MongoDB plut√¥t que SQL
