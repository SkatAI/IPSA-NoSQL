- [S04.02 Schema Design patterns](#s0402-schema-design-patterns)
  - [Schema Design](#schema-design)
  - [Rappel Normalisation](#rappel-normalisation)
    - [Normal forms](#normal-forms)
- [1NF](#1nf)
  - [Transactions](#transactions)
      - [Rappel ACID](#rappel-acid)
    - [Example transaction avec PostgreSQL](#example-transaction-avec-postgresql)
    - [Example transaction dans mongosh](#example-transaction-dans-mongosh)
    - [R√©f√©rencement (jointure) vs int√©gration (embedding)](#r√©f√©rencement-jointure-vs-int√©gration-embedding)
      - [Avantages de l'int√©gration / Embedding](#avantages-de-lint√©gration--embedding)
      - [Limitations de l'int√©gration](#limitations-de-lint√©gration)
    - [R√©f√©rencement (jointure)](#r√©f√©rencement-jointure)
      - [Avantages du r√©f√©rencement](#avantages-du-r√©f√©rencement)
      - [Limitations du r√©f√©rencement](#limitations-du-r√©f√©rencement)
  - [Conception du sch√©ma et nature des relations](#conception-du-sch√©ma-et-nature-des-relations)
      - [Un-√†-un (one to one)](#un-√†-un-one-to-one)
      - [Un-√†-quelqu'uns (one to few) - dizaine](#un-√†-quelquuns-one-to-few---dizaine)
      - [Un-√†-plusieurs (one to many) - centaines](#un-√†-plusieurs-one-to-many---centaines)
      - [Un-√†-beaucoup (one to squillions)](#un-√†-beaucoup-one-to-squillions)
        - [Example de sch√©ma pour un server + log](#example-de-sch√©ma-pour-un-server--log)
      - [Plusieurs-√†-plusieurs (many to many)](#plusieurs-√†-plusieurs-many-to-many)
    - [R√©capitulatif¬†:](#r√©capitulatif)
  - [Mod√®les de Schema design](#mod√®les-de-schema-design)
    - [Mod√®le de r√©f√©rence √©tendu](#mod√®le-de-r√©f√©rence-√©tendu)
    - [Le mod√®le des valeurs aberrantes (outlier pattern)](#le-mod√®le-des-valeurs-aberrantes-outlier-pattern)
  - [Autres patterns](#autres-patterns)
    - [The Bucket Pattern](#the-bucket-pattern)
    - [The Computed Pattern](#the-computed-pattern)
    - [The Polymorphic Pattern](#the-polymorphic-pattern)
  - [Recap](#recap)
    - [**üí° Conclusion**](#-conclusion)
- [D√©finition et validation du sch√©ma](#d√©finition-et-validation-du-sch√©ma)
      - [Schema implicite lors de la creation](#schema-implicite-lors-de-la-creation)
    - [**üîπ Quand faut-il cr√©er une collection manuellement ?**](#-quand-faut-il-cr√©er-une-collection-manuellement-)
      - [**Exemple de cr√©ation explicite d‚Äôune collection**](#exemple-de-cr√©ation-explicite-dune-collection)
    - [**üîπ Limitations de la cr√©ation automatique**](#-limitations-de-la-cr√©ation-automatique)
    - [Application d'un type de donn√©es](#application-dun-type-de-donn√©es)
- [Schema Validation in MongoDB](#schema-validation-in-mongodb)
  - [How Schema Validation Works](#how-schema-validation-works)
  - [Building Blocks of Validation](#building-blocks-of-validation)
    - [Nested Objects](#nested-objects)
  - [Fine-Tuning Validation Behavior](#fine-tuning-validation-behavior)
  - [Pratique](#pratique)
  - [pratique](#pratique-1)
  - [Liens](#liens)


# S04.02 Schema Design patterns


## Schema Design

Le design du sch√©ma MongoDB est la partie la plus critique de la conception d'une base de donn√©es.

Si vous concevez le sch√©ma MongoDB comme un sch√©ma relationnel, vous perdez de vue les avantages et la puissance de NoSQL.

Lire l'article : [Conception du sch√©ma MongoDB¬†: meilleures pratiques de mod√©lisation des donn√©es](https://www.mongodb.com/developer/products/mongodb/mongodb-schema-design-best-practices/)


Comment mod√©liser les donn√©es pour MongoDB ?


> Cela d√©pend. En effet, les bases de donn√©es documentaires ont un vocabulaire riche qui est capable d'exprimer les relations de donn√©es de mani√®re plus nuanc√©e que SQL. Il y a beaucoup de choses √† consid√©rer lors du choix d'un sch√©ma.
> - Votre application est-elle intense en lecture ou en √©criture¬†?
> - Quelles donn√©es sont fr√©quemment consult√©es ensemble¬†?
> - Quelles sont vos priorit√©s en mati√®re de performances¬†?
> - Comment vos donn√©es vont-elles cro√Ætre et √©voluer¬†?

Dans les bases de donn√©es SQL, la **normalisation** consiste √† r√©partir les donn√©es en tables, afin de ne pas les dupliquer.

- 1 utilisateur
- a plusieurs moyens de transport -> v√©lo, voiture, ..., jet priv√©
- a un emploi
- a une addresse
- a effectu√© plusieurs visites sur un site

En sql : tables multiples, appliquer les formes de normalisation, etc.

Avec MongoDB, il n'y a¬†:

- ni de processus formel
- ni d'algorithmes
- ni de r√®gles

C'est qui n'est absolument pas flippant¬†!!! üò≥üò≥üò≥


![No Rules](./../img/no_rules.gif)


Ce qui compte, c'est de concevoir un sch√©ma qui fonctionne au mieux **pour l'application finale**.

=> Deux applications diff√©rentes qui utilisent exactement les m√™mes donn√©es peuvent avoir des sch√©mas tr√®s diff√©rents si les donn√©es sont utilis√©es diff√©remment.

üê≤üê≤üê≤ **L'application dicte le sch√©ma¬†!**

## Rappel Normalisation


The general goal of **normalization** is to reduce data **redundancy** and **dependency** by organizing data into **separate, related tables**.

More formally, a database is normalized if:

> **all column values depend only on the table primary key,**

The idea of denormalization is to have data **redundancy** to simplify queries and make OLAP queries faster.

**Redundant data** : the same data / info exists in multiple tables

SELECT queries involve fewer JOINs.

However INSERT, UPDATE, DELETE queries are more complex as multiple tables must be accounted for. Therefore data integrity is more complex to preserve.

### Normal forms

A normal form is a **rule** that defines a level of normalization.


* UNF: Unnormalized form
* 1NF: First normal form
* 2NF: Second normal form
* 3NF: Third normal form

# 1NF

**Each field contains a single value**


> A relation is in first normal form
>
> if and only if
>
> no attribute domain has relations as elements.

* [Wikipedia: Satisfying 1NF](https://en.wikipedia.org/wiki/Database_normalization#Satisfying_1NF)

The table is in 2NF iff :

* The table is in 1NF,
* it has a single attribute unique identifier (UID),
* and every non key attribute is dependent on the entire UID


Some cases of non-compliance with 2NF

* Derived or calculated fields:
    * Relation: ```Employee(EmployeeID, Name, BirthDate, Age)```
    * Here, ```Age``` is derived from ```BirthDate```, causing a partial dependency.

A relation R is in 3NF if and only if both of the following conditions hold:

* The relation is in second normal form (2NF).
* No non-prime attribute of R is transitively dependent on the primary key.

> A **transitive dependency** occurs when a non-prime attribute (an attribute that is not part of any key) depends on another non-prime attribute, rather than depending directly on the primary key.

where:

* non-prime attribute: an attribute that is not part of any key

For the statisticians in the room, it's a bit like **confonders**.

So basically, in a table you would have 2 columns that are not keys that sort of depends on each other.



## Transactions

**Single Document Operations**: MongoDB guarantees ACID properties for operations that affect a single document. This is a fundamental aspect of MongoDB's design. So, if all your CRUD operations are contained entirely within **a single document**, then yes, they are ACID compliant.

**Embedded Documents** (within a single document): When you have embedded documents  within a single document, and your CRUD operations only modify data within that **one document**, then the entire operation is ACID compliant because it's still considered a single document operation. For example, updating a field inside an embedded document using $set or pushing a new element to an array within the main document using $push is ACID compliant.

**Multi-document operations** (without transactions): Not ACID compliant. You get atomicity at the document level, but not across multiple documents.

#### Rappel ACID

1. **Atomicit√© (Atomicity)** : Une transaction est enti√®rement ex√©cut√©e ou annul√©e en cas d‚Äô√©chec (tout ou rien).
2. **Coh√©rence (Consistency)** : Une transaction am√®ne la base d‚Äôun √©tat valide √† un autre √©tat valide, respectant les contraintes d‚Äôint√©grit√©.
3. **Isolation (Isolation)** : Les transactions concurrentes s‚Äôex√©cutent sans interf√©rer entre elles, comme si elles √©taient ex√©cut√©es s√©quentiellement.
4. **Durabilit√© (Durability)** : Une fois valid√©e, une transaction est d√©finitivement enregistr√©e, m√™me en cas de panne.



### Example transaction avec PostgreSQL

```SQL
-- Start a transaction
BEGIN;

-- Perform multiple operations within the transaction
-- Assuming you have tables 'accounts' and 'transactions'

-- Example 1: Update the balance of account 1 (Debit)
UPDATE accounts
SET balance = balance - 100
WHERE account_id = 1;

-- Example 2: Update the balance of account 2 (Credit)
UPDATE accounts
SET balance = balance + 100
WHERE account_id = 2;

-- Example 3: Insert a record into the 'transactions' table to log the transaction
INSERT INTO transactions (account_id_from, account_id_to, amount, transaction_date)
VALUES (1, 2, 100, NOW());

-- Commit the transaction
COMMIT;

```



### Example transaction dans mongosh

```javascript
// Connect to MongoDB
conn = new Mongo();
db = conn.getDB("mydatabase");

// Start a session
let session = db.getMongo().startSession();

// Start a transaction within the session
session.startTransaction();

try {
  // Perform multiple operations within the transaction

  // Insert a document into collection1
  let result1 = db.collection1.insertOne(
    { name: "Bob", age: 40 },
    { session: session }
  );

  // Update a document in collection2
  let result2 = db.collection2.updateOne(
    { _id: 1 },
    { $inc: { value: 20 } },
    { session: session }
  );

  // Print the results (including $txnNumber and lsid, if available)
  print("Insert Result 1:", result1);
  print("Update Result 2:", result2);

  // Commit the transaction
  session.commitTransaction();
  print("Transaction committed successfully.");
} catch (error) {
  // Abort the transaction in case of an error
  session.abortTransaction();
  print("Transaction aborted. Error:", error);
} finally {
  // End the session
  session.endSession();
}
```

Retour au type de schema des donn√©es

### R√©f√©rencement (jointure) vs int√©gration (embedding)

- Int√©gration: Denormalisation
- Referencement: Normalisation

On compare les 2 approches suivantes:

- R√©f√©rencement: le document a une r√©f√©rence vers un autre document

```json
// user collection
{
    "_id": "bart_user_id",
    "name": "Bart",
    "school": "Springfied elementary"
}

// transportation collection
{
    "_id": "some_id",
    "user_id": "bart_user_id",
    "type": "bike",
    "avg_speed": "30kph",
},
{
    "_id": "some_id",
    "user_id": "bart_user_id",
    "type": "Skate board",
    "avg_speed": "10kph",
}

```


- int√©gration / imbrication (embedding): le sous-document fait partie du document principal


```json
// user collection
{
    "_id": "some user_id",
    "name": "Bart",
    "school": "Springfied elementary",
    "transportation": [
        {
            "type": "bike",
            "avg_speed": "30kph",
        },
        {
            "type": "Skate board",
            "avg_speed": "10kph",
        }
    ]
}

```

#### Avantages de l'int√©gration / Embedding

- On r√©cup√®re toutes les informations en une seule requ√™te.
- on √©vite les jointures
- une seule op√©ration pour la mise √† jour des donn√©es imbriqu√©es.


Pour les transactions¬†:

- Par d√©faut, toutes les op√©rations CRUD sur un seul document sont conformes √† ACID.


#### Limitations de l'int√©gration

- La taille des documents impacte n√©gativement la performance des requetes. Il faut faire attention a ne pas tout mettre dans un document, mais restreindre aux informations pertinentes.

- Les documents de MongoDB sont limit√©s √† une taille de **16¬†Mb**.

Il y a donc un √©quilibre √† trouver entre exhaustivit√© des informations et taille des documents

### R√©f√©rencement (jointure)

L'autre option pour concevoir le sch√©ma est de r√©f√©rencer un autre document √† l'aide de l'ID d'objet unique d'un document et de les connecter √† l'aide de l'op√©rateur `$lookup`.

Le r√©f√©rencement fonctionne de la m√™me mani√®re que l'op√©rateur `JOIN` dans une requ√™te SQL. Il permet de r√©partir les donn√©es pour effectuer des requ√™tes plus efficaces et plus √©volutives, tout en maintenant les relations entre les donn√©es.

#### Avantages du r√©f√©rencement

- En r√©partissant les donn√©es, on obtient des documents plus petits et donc moins susceptibles d'atteindre la limite de 16¬†Mo par document.
- Certaines donn√©es ne sont pas consult√©es aussi fr√©quemment que d'autres donn√©es. Il est donc logique de les s√©parer des donn√©es principales.
- Le r√©f√©rencement r√©duit la duplication des donn√©es.

#### Limitations du r√©f√©rencement

- MongoDB est moins efficace pour les jointures qu'une base de donn√©es SQL.

## Conception du sch√©ma et nature des relations

Il faut tenir compte de la nature des relations entre les entit√©s

#### Un-√†-un (one to one)

Mod√©lis√© sous forme de paires cl√©-valeur dans la base de donn√©es.

Par exemple :

- train <-> nombre de passagers
- utilisateur <-> date de naissance
- arbre <-> vari√©t√©
- humain <-> taille

#### Un-√†-quelqu'uns (one to few) - dizaine

Une petite s√©quence de donn√©es associ√©e √† l'entit√© principale.

- une personne a quelques adresses (1, 2, ... 5)
- une playlist a quelques morceaux
- une recette a quelques ingr√©dients
- une ligne de bus a plusieurs arr√™ts


#### Un-√†-plusieurs (one to many) - centaines

- une salle de sport a beaoucp d'utilisateurs
- un produit a beaucoup de pi√®ces
- un compte instagram a beaucoup de followers

#### Un-√†-beaucoup (one to squillions)

potentiellement des millions de sous-documents

- universit√© <-> des milliers d'√©tudiants
- compte insta d'un(e) people <-> des millions de followers, de commentaires
- serveur <-> log events
- IoT: des millions d'√©v√®nements


##### Example de sch√©ma pour un server + log

Une application de journalisation de serveur (server log). Chaque serveur enregistre une quantit√© importante d'ev√®nements.

On a donc 2 entit√©s: `server` et `event`.

3 options

- le document `server` int√®gre tous les `events` associ√©es au `server`. forte probablilit√© que cela depasse les 16 Mb par document assez rapidement
- separer les 2 collections et faire un `@lookup`. Mais c'est plus lent pour r√©cuperer tous les evenements d'un serveur
- renverser l'integration et ins√©rer le nom du `server` dans chaque document `event`! duplication des donn√©es mais rapidit√© de requetage et pas de risque de d√©passer la taille de 16Mb


#### Plusieurs-√†-plusieurs (many to many)

Exemple d'une application de planification de projet¬†:

- un utilisateur peut avoir plusieurs t√¢ches
- une t√¢che peut avoir plusieurs utilisateurs assign√©s.

Un sch√©ma efficace consiste √† stocker

- l'ID des utilisateurs dans le document de t√¢che
- l'ID des t√¢ches dans le document utilisateur.

Utilisateurs¬†:

```json
{
    "_id": ObjectID("AAF1"),
    "name": "Kate Pineapple",
    "tasks": [ObjectID("ADF9"), ObjectID("AE02"), ObjectID("AE73")]
}
```

T√¢ches¬†:

```json
{
  "_id": ObjectID("ADF9"),
  "description": "√âcrire un billet de blog sur la conception de sch√©mas MongoDB",
  "due_date": ISODate("2014-04-01"),
  "owners": [ObjectID("AAF1"), ObjectID("BB3G")]
}
```

Dans cet exemple, vous pouvez voir que chaque `utilisateur` a un sous-tableau de `t√¢ches` li√©es, et que chaque t√¢che a un sous-tableau de propri√©taires pour chaque √©l√©ment de notre application de t√¢ches.

### R√©capitulatif¬†:

- **Un-√†-un** - Pr√©f√©rez les paires cl√©-valeur dans le document
- **Un-√†-quelques-uns** - Pr√©f√©rez l'int√©gration
- **Un-√†-plusieurs** - Pr√©f√©rez l'int√©gration
- **Un-√†-des-squillions** - Pr√©f√©rez le r√©f√©rencement
- **Plusieurs-√†-plusieurs** - Pr√©f√©rez le r√©f√©rencement crois√©

R√®gles g√©n√©rales pour la conception de sch√©mas MongoDB¬†:

- R√®gle¬†1¬†: privil√©giez l'int√©gration, sauf s'il existe une bonne raison  de ne pas le faire.
- R√®gle¬†2¬†: la n√©cessit√© d'acc√©der √† un objet de fa√ßon ind√©pendante est une bonne raison  de ne pas l'int√©grer.
- R√®gle¬†3¬†: √©vitez les jointures et les recherches si possible, mais n'ayez pas peur si elles peuvent fournir une meilleure conception de sch√©ma.
- R√®gle¬†4¬†: les tableaux ne doivent pas cro√Ætre sans limite. Lorsqu'il y a plus de quelques centaines de documents imbriqu√©s, il vaut mieux les r√©f√©rencer; De m√™me, Lorsqu'il y a plus de quelques milliers de documents imbriqu√©s, n'utilisez pas de tableau de r√©f√©rences par ID. Enfin les tableaux √† forte cardinalit√© (nombreuse valeurs potentielles) sont une bonne raison de ne pas int√©grer.
- R√®gle¬†5¬†: comme toujours, avec MongoDB, la fa√ßon dont vous mod√©lisez vos donn√©es d√©pend enti√®rement des mod√®les d'acc√®s aux donn√©es de votre application. Vous souhaitez structurer vos donn√©es pour qu'elles correspondent √† la mani√®re dont votre application les interroge et les met √† jour.


## Mod√®les de Schema design
Examinons 2 mod√®les de Schema pour illustrer la mani√®re dont l'application dicte la conception du sch√©ma de donn√©es.

### Mod√®le de r√©f√©rence √©tendu

Passons en revue cet article

<https://www.mongodb.com/developer/products/mongodb/schema-design-anti-pattern-massive-arrays/>

> L'une des r√®gles empiriques lors de la mod√©lisation des donn√©es dans MongoDB consiste √† dire que les donn√©es auxquelles on acc√®de en m√™me temps doivent √™tre stock√©es ensemble.

-> Un b√¢timent a de nombreux employ√©s¬†: potentiellement trop pour la limite de document de 16¬†Mo.

On inverse la situation avec

-> L'employ√© appartient √† un b√¢timent¬†: on int√®gre les informations du b√¢timent dans le document de l'employ√©.

> Si l'application affiche fr√©quemment des informations sur un employ√© et son b√¢timent ensemble, ce mod√®le est probablement judicieux.

Probl√®me¬†: on a beaucoup trop de duplication de donn√©es.

La mise √† jour des informations d'un b√¢timent¬†implique de  mettre √† jour tous les documents d'employ√©s.

Alors, s√©parons les employ√©s et le b√¢timent en 2 collections distinctes et utilisons des `$lookups`.

Mais les `$lookups` sont co√ªteux.

Nous utilisons donc le [mod√®le de r√©f√©rence √©tendu](https://www.mongodb.com/blog/post/building-with-patterns-the-extended-reference-pattern) (extended reference pattern)  o√π on duplique certaines, mais pas toutes, des donn√©es dans les deux collections. On ne duplique que les donn√©es qui sont fr√©quemment consult√©es ensemble.

> Par exemple, si l'application poss√®de une page de profil utilisateur qui affiche des informations sur l'utilisateur ainsi que le nom du b√¢timent et la r√©gion o√π il / elle travaille, on int√©gre le nom du b√¢timent et la r√©gion dans le document de l'employ√© mais les autres infos li√©es au b√¢timent.

### Le mod√®le des valeurs aberrantes (outlier pattern)

Le mod√®le des valeurs outliers: seuls quelques documents poss√®dent une quantit√© √©norme de documents imbriqu√©s.

https://www.mongodb.com/blog/post/building-with-patterns-the-outlier-pattern

Consid√©rez une collection de livres et la liste des utilisateurs qui ont achet√© le livre.

```json
{
    "_id": ObjectID("507f1f77bcf86cd799439011")
    "title": "Une histoire ennuyeuse",
    "author": "Sam K. Boring",
    ‚Ä¶,
    "customers_purchased": ["user00", "user01", "user02"]

}
```

La plupart des livres ne se vendent qu'√† quelques exemplaires. C'est la longue tra√Æne (long tail) des ventes de livres.

Pour la plupart des livres on peut simplement int√©grer la liste des acheteurs  (ID et quelques infos pertinentes) dans le document du livre.

Une faible quantit√© de livres se vendent √† des millions d'exemplaires. Impossible d'imbriquer les acheteurs dans le doc du livre.

En ajoutant un champ, un flag, ou indicateur, qui signale que le livre est tres populaire, on peut adapter le schema en fonction de cette indicateur.


```json
{
    "_id": ObjectID("507f191e810c19729de860ea"),
    "title": "Harry Potter",
    "author": "J.K. Rowling",
    ‚Ä¶,
    // on evite d'integrer les acheteurs pour ce livre
    //    "customers_purchased": ["user00", "user01", "user02", ‚Ä¶, "user9999"],
   "outlier": "true"
}
```

Dans le code de l'application, nous testons la pr√©sence de cet indicateur et traitons les donn√©es diff√©remment si l'indicateur est pr√©sent.
Par exemple en referencant les acheteurs des livres tres populaires au lieu de les imbriquer.

Le mod√®le des valeurs aberrantes est fr√©quemment utilis√© dans les situations o√π la popularit√© est un facteur, comme dans les relations sur les r√©seaux sociaux, les ventes de livres, les critiques de films,

## Autres patterns


### The Bucket Pattern
üìå When to use it?

- When dealing with time-series data (logs, IoT, events).
- To reduce the number of documents.

‚úÖ Example: Store sensor readings in buckets

Instead of creating a new document for every sensor reading, group them into time buckets.

```json
{
  "_id": "sensor_1_2024-02-05",
  "sensor_id": 1,
  "date": "2024-02-05",
  "readings": [
    { "time": "08:00", "value": 22.5 },
    { "time": "08:30", "value": 23.1 }
  ]
}
```

- üí° Advantages: Reduces document count, improves query performance.
- ‚ö†Ô∏è Limitations: Harder to update individual readings.


###  The Computed Pattern
üìå When to use it?

- When you frequently compute a value that rarely changes.
- To avoid re-calculating values on every query.

‚úÖ Example: Store total order value instead of computing every time

```json
{
  "_id": 101,
  "user_id": 1,
  "items": [
    { "name": "Laptop", "price": 1200 },
    { "name": "Mouse", "price": 50 }
  ],
  "total_price": 1250
}
```

- üí° Advantages: Improves read performance.
- ‚ö†Ô∏è Limitations: Must ensure updates stay synchronized.


### The Polymorphic Pattern

üìå When to use it?

- When documents in the same collection have different attributes.
- Useful when storing similar but distinct entities.

‚úÖ Example: Store users and admins in the same collection

```json
{
  "_id": 1,
  "type": "user",
  "name": "Alice",
  "email": "alice@example.com"
}

{
  "_id": 2,
  "type": "admin",
  "name": "Bob",
  "email": "bob@example.com",
  "admin_permissions": ["manage_users", "delete_posts"]
}
```

- üí° Advantages: Avoids multiple collections.
- ‚ö†Ô∏è Limitations: Queries may need filtering by type.

## Recap

| **Pattern**     | **Use Case**                            | **Example**                                   |
| --------------- | --------------------------------------- | --------------------------------------------- |
| **Embedding**   | Small, frequently accessed data         | Store a user with their addresses             |
| **Referencing** | Large, reusable data needing updates    | Users & orders stored separately              |
| **Bucket**      | Time-series or grouped data             | Sensor readings stored in time buckets        |
| **Outlier**     | Avoids large documents with exceptions  | Move excess comments to a separate collection |
| **Computed**    | Avoids expensive calculations           | Store total order price in the document       |
| **Polymorphic** | Multiple object types in one collection | Users & admins stored together                |



### **üí° Conclusion**

- **Embedding** is best for **fast reads** but can lead to large documents.
- **Referencing** is better for **scalability** but requires joins (`$lookup`).
- **Bucket** pattern is great for **time-series data**.
- **Outlier** prevents performance issues due to **large documents**.
- **Computed** speeds up queries by **precomputing values**.
- **Polymorphic** allows flexibility **within the same collection**.

Choosing the **right pattern** depends on **query patterns, data size, and update frequency**. üöÄ

-----

# D√©finition et validation du sch√©ma

Sans validation explicite il est possible de mettre n'importe quoi dans une collection.

Par exemple, l'√¢ge de l'utilisateur

- 32 (int)
- "32" (string)
- trente-deux
- 432
- null
- ""
- "la recette de cuisine du canard a l'orange"

etc etc.

L'absence de validation quant aux valeurs acceptables dans une collection transfert la complexit√© au niveau applicatif.

C'est le chaos!


#### Schema implicite lors de la creation


Dans MongoDB, **les collections sont cr√©√©es automatiquement** lorsqu‚Äôun **premier document est ins√©r√©** dans une collection inexistante. Il n'est pas n√©cessaire de la cr√©er manuellement au pr√©alable.



**üìå Exemple**


```javascript
db.nouvelleCollection.insertOne({ nom: "Alice", age: 25 });
```

‚úÖ Si `nouvelleCollection` n‚Äôexiste pas, MongoDB la cr√©e automatiquement et ins√®re le document.



### **üîπ Quand faut-il cr√©er une collection manuellement ?**

Vous pourriez vouloir utiliser `createCollection()` si vous avez besoin de :
1. **D√©finir des param√®tres sp√©cifiques** comme une **collection cap√©e** (taille fixe).
2. **Appliquer des r√®gles de validation** pour garantir l‚Äôint√©grit√© des donn√©es.

#### **Exemple de cr√©ation explicite d‚Äôune collection**

```javascript
db.createCollection("utilisateurs", {
  capped: true,
  size: 1024
});
```

‚úÖ Cela cr√©e une **collection cap√©e** avec une **taille fixe de 1024 octets**.


### **üîπ Limitations de la cr√©ation automatique**

- La collection est **cr√©√©e uniquement lorsqu‚Äôun document est ins√©r√©**, pas lorsqu‚Äôon ex√©cute un `find()` vide.
- La collection est cr√©√©e **sans r√®gles de validation** (sauf si elles sont d√©finies explicitement).
- Les index **ne sont pas cr√©√©s automatiquement** (sauf pour `_id`).

**üöÄ Conclusion :** Oui, MongoDB **cr√©e automatiquement les collections** lors de l‚Äôinsertion de donn√©es, mais une cr√©ation explicite est utile pour des param√®tres avanc√©s.


### Application d'un type de donn√©es

D√©clarer le type de donn√©es lors de la d√©finition du sch√©ma

```bash
db.createCollection("movies", {
    validator: {
        $jsonSchema: {
            bsonType: "object",
            required: ["year", "title"],  // Champs qui doivent √™tre pr√©sents
            properties: {
                year: {
                    bsonType: "int",  // Force que `year` soit un entier
                    required: "true",
                    description: "Doit √™tre un entier et est obligatoire"
                },
                title: {
                    bsonType: "string",
                    description: "Titre du film, doit √™tre une cha√Æne de caract√®res si pr√©sent"
                },
                imdb: {
                    bsonType: "object",  // Objet imbriqu√© pour les donn√©es IMDb
                    properties: {
                        rating: {
                            bsonType: "double",  // La note IMDb doit √™tre un float
                            description: "Doit √™tre un float si pr√©sent"
                        }
                    }
                }
            }
        }
    }
})
```

Points cl√©s¬†:

- **bsonType**: sp√©cifie le type de donn√©es BSON pour le champ (par exemple, int, string, array, object).
- **required**: garantit que des champs sp√©cifiques sont obligatoires.
- **properties**: d√©finit les contraintes pour chaque champ.
- **description**: ajoute une description utile pour les erreurs de validation.

MongoDB prend en charge la validation de sch√©ma √† partir de la version¬†3.6, ce qui vous permet d'appliquer des types de donn√©es et d'autres contraintes sur les champs au sein d'une collection.

Ceci est r√©alis√© √† l'aide de l'operateur `$jsonSchema` lors de la cr√©ation ou de la mise √† jour d'une collection.

<https://www.digitalocean.com/community/tutorials/how-to-use-schema-validation-in-mongodb>

Lorsque vous ajoutez des r√®gles de validation √† une collection existante, les nouvelles r√®gles n'affecteront pas les documents existants tant que vous n'essayez pas de les modifier.

# Schema Validation in MongoDB

MongoDB is known for its flexibility - you can store documents without predefined structures. However, as your application grows, you might want to ensure your data follows certain rules. This is where schema validation comes in.

## How Schema Validation Works

When you create a collection with validation, MongoDB will check every new document (and updates to existing ones) against your rules.  Here's what the basic structure looks like:

```javascript
db.createCollection("collectionName", {
   validator: {
      $jsonSchema: {
         bsonType: "object",
         required: ["field1", "field2"],
         properties: {
            field1: { type: "string" },
            field2: { type: "number" }
         }
      }
   }
})
```

The `$jsonSchema` keyword tells MongoDB that we're using JSON Schema validation. Inside this schema, we define our rules using various building blocks.

## Building Blocks of Validation

The most fundamental components are:

First, we specify which fields are mandatory using `required`. These fields must be present in every document.

Next, we define `properties` - this is where we describe what each field should look like. For each property, we can specify its type and additional rules. For example, if you're storing someone's age, you might want to ensure it's always a number and perhaps even set a minimum / maximum value.

Let's look at how we handle more complex structures:

### Nested Objects

Sometimes your data has natural hierarchies. For instance, an address isn't just one piece of information - it has streets, cities, and zip codes. Here's how you validate nested structures:

```javascript
properties: {
   address: {
      bsonType: "object",
      required: ["city"],      // City is mandatory in addresses
      properties: {
         city: { type: "string" },
         zip: { type: "string" }
      }
   }
}
```

## Fine-Tuning Validation Behavior

MongoDB gives you control over how strict your validation should be. You can set two important behaviors:

The `validationAction` determines what happens when a document fails validation:
- "error" (default): Reject the document completely
- "warn": Accept the document but log a warning (great during development!)

The `validationLevel` controls when validation happens:
- "strict" (default): Check all inserts and updates
- "moderate": Skip validation for existing documents that don't match the schema

Remember that validation only happens when documents are modified or inserted. Existing documents won't be validated until you try to update them. This makes it safe to add validation to collections that already contain data.

Through schema validation, MongoDB offers a balance between flexibility and control. You can start with a loose schema during early development, then gradually add more validation rules as your application's needs become clearer. This progressive approach to data quality helps ensure your database remains both reliable and adaptable.

## Pratique


Petit exemple sur les jeux de donn√©es d'arbres¬†

```json
{
        "idbase":249403,
        "location_type":"Arbre",
        "domain":"Alignement",
        "arrondissement":"PARIS 20E ARRDT",
        "suppl_address":"54",
        "number":null,
        "address":"AVENUE GAMBETTA",
        "id_location":"1402008",
        "name":"Tilleul",
        "genre":"Tilia",
        "species":"tomentosa",
        "variety":null,
        "circumference":85,
        "height":10,
        "stage":"Adulte",
        "remarkable":"NON",
        "geo_point_2d":"48.86685102642415, 2.400262189227641"
    },
```

√©crire un sch√©ma et un validateur pour ces donn√©es

le validateur doit appliquer

- height >= 0 et <100
- stage ['']


## pratique

prenez une version JSON du jeux de donn√©es trees o√π les colonnes avec des valeurs null ont √©t√© supprim√©es

1. sans contrainte
   - ins√©rer toutes les donn√©es sans validation
   - requ√™te pour v√©rifier les valeurs absurdes¬†: height, geolocation
2. approche plus contr√¥l√©e
   - √©crire un sch√©ma et un validateur¬†: en utilisant le validateur $jsonSchema de MongoDB pour ¬´¬†ex√©cuter √† blanc¬†¬ª votre validation de donn√©es.
   - v√©rifier le nombre de documents ignor√©s
   - √©crire un validateur qui r√©cup√®re le plus de documents possible tout en excluant les valeurs absurdes
3. index
   - ajouter un index unique sur la g√©olocalisation

dans MongoDB, le validateur de sch√©ma est g√©n√©ralement cr√©√© avec la collection, et non comme une √©tape distincte

## Liens

Mod√®les de conception de sch√©ma¬†: https://learn.mongodb.com/courses/schema-design-patterns
