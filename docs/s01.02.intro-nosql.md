# NoSQL et bases de donn√©es graphes

Ce cours aborde deux types sp√©cifiques de bases de donn√©es NoSQL
- MongoDB, qui est une base de donn√©es NoSQL,
- Neo4j, qui repr√©sente la famille des bases de donn√©es de type graphes (graph database).


## Qu'est-ce qu'une base de donn√©es ?

<img src="./../img/memes/what-is-a-database.png" width='50%' style='display: block; margin: auto; ' alt= "what is a database asks Sheldon?">

On entends parfois le mot base de donn√©es pour d√©signer un fichier Excel. Ca me donne des boutons.


Comment peut-on mettre quelque chose d'aussi simple qu'un fichier CSV ou Excel au m√™me niveau que ces merveilles d'ing√©nierie que sont PostgreSQL, Weaviate, MongoDB, Neo4j, Redis, MySQL etc...

J'ai donc demand√© √† mon ami GPT-4 de me donner une d√©finition d'une base de donn√©es :

> En termes simples :
  "Une database est comme un carnet intelligent ou un syst√®me de classement qui vous aide √† garder une trace de nombreuses informations et √† trouver exactement ce dont vous avez besoin en un rien de temps."

ce qui inclut d√©finitivement les fichiers CSV, les fichiers Excel, les fichiers JSON, les fichiers XML et tant d'autres formats simples bas√©s sur un seul fichier.

Si nous cherchons la d√©finition d'une database dans une source de connaissance plus classique et v√©n√©rable, comme l'[Encyclop√©die Britannica](https://www.britannica.com/technology/database), nous obtenons :

> base de donn√©es, toute collection de donn√©es ou d'informations sp√©cialement organis√©e pour une recherche rapide par ordinateur. Les databases sont structur√©es pour faciliter le storage, l'extraction, la modification et la deletion des donn√©es en conjonction avec diverses op√©rations de traitement de donn√©es.

Voir aussi l'article database sur [Wikipedia](https://en.wikipedia.org/wiki/Database).

Tr√®s int√©ressant. Nous ne parlons plus seulement de trouver rapidement l'information (la partie **recherche**) mais aussi de :

- stockage
- modification
- suppression
- Administration.

C'est l√† qu'un simple fichier de type spreadsheet ne correspond plus √† l'objectif.

## Ce que l'on attend d'un DBMS

Un syst√®me de gestion de base de donn√©es (DBMS) se distingue d'un simple spreadsheet par plusieurs fonctionnalit√©s essentielles. Voici une comparaison d√©taill√©e :

| Feature                        | Description                                                                                                     | Excel | DBMS |
| ------------------------------ | --------------------------------------------------------------------------------------------------------------- | ----- | ---- |
| **Data Storage and Retrieval** | Stocke les donn√©es de mani√®re organis√©e et les r√©cup√®re selon les besoins.                                      | ‚úÖ     | ‚úÖ    |
| **Data Manipulation**          | Permet d'ajouter, modifier ou supprimer des donn√©es.                                                            | ‚úÖ     | ‚úÖ    |
| **Data Querying**              | Permet de poser des questions complexes (queries) sur les donn√©es.                                              | ‚úîÔ∏è     | ‚úÖ    |
| **Data Organization**          | Structure les donn√©es dans des formats comme des tables, documents ou graphes pour faciliter la gestion.        | ‚úÖ     | ‚úÖ    |
| **Data Sharing**               | Permet √† plusieurs utilisateurs ou applications d'utiliser la database simultan√©ment.                           | ‚úÖ     | ‚úÖ    |
| **Data Security**              | Prot√®ge les donn√©es contre les acc√®s non autoris√©s ou la corruption.                                            | ‚úîÔ∏è     | ‚úÖ    |
| **Concurrency Control**        | G√®re plusieurs utilisateurs modifiant les donn√©es en m√™me temps sans conflits.                                  |       | ‚úÖ    |
| **Backup and Recovery**        | Garantit que les donn√©es ne sont pas perdues et peuvent √™tre restaur√©es en cas de d√©faillance.                  | ‚úîÔ∏è     | ‚úÖ    |
| **Data Integrity**             | Garantit que les donn√©es restent pr√©cises, coh√©rentes et fiables.                                               |       | ‚úÖ    |
| **Performance Optimization**   | Fournit des outils pour optimiser la vitesse et l'efficacit√© des retrievals et updates de donn√©es.              |       | ‚úÖ    |
| **Support for Transactions**   | Garantit qu'un groupe d'op√©rations (transactions) est compl√©t√© enti√®rement ou pas du tout. <br> ACID compliance |       | ‚úÖ    |

## Un br√®ve histoire des bases de donn√©es


> tldr; Notre cours d√©bute il y a 15 ans, en 2009, soit 20 ans apr√®s la naissance de **PostgreSQL**.

<img src="./../img/evolution-of-databases.png" width='80%' style='display: block; margin: auto; padding-bottom: 30px;' alt= "Evolution of database from 1970 to 2024">

### 1970s - Le d√©but de l'√®re relationnelle

- **1970** : **[Edgar Codd](https://en.wikipedia.org/wiki/Edgar_F._Codd)** publie "[A Relational Model of Data for Large Shared Data Banks](https://github.com/SkatAI/epita-mongodb/blob/master/pdfs/codd.pdf)"
- **1974** : **IBM** d√©veloppe System R, le premier prototype de DBMS SQL
- **1979** : **Oracle** lance la premi√®re impl√©mentation SQL commerciale

### 1980s - La domination du relationnel

- **1989** : D√©but du d√©veloppement de Postgres (maintenant [PostgreSQL](https://www.postgresql.org/)) √† UC Berkeley
  - üéñÔ∏èüéñÔ∏èüéñÔ∏è database multi-usage de r√©f√©rence.
  - peut g√©rer le no-sql & vector,
  - nombreuses extensions (http, postgis, ...).
  - performances exceptionnelles.
  - et OPEN SOURCE (gratuit, efficace et s√©curis√©).

### 1990s - La vague orient√©e objet

- **1991** : Les Object-Oriented Databases gagnent en attention. <br> La plupart des OODBs des ann√©es 90 ne sont plus utilis√©es. Mais elles ont influenc√© l'√©volution des databases SQL et NoSQL.
- **1995** : MySQL est publi√© en open source

### 2000s - Le d√©but de la r√©volution NoSQL

- 2 papers importants qui posent les bases des syst√®mes NoSQL : [BigTable paper](https://research.google.com/archive/bigtable-osdi06.pdf) (Google, 2004) et [Dynamo paper](https://www.amazon.science/publications/dynamo-amazons-highly-available-key-value-store) (Amazon, 2007)

Et en **2009**, 2 nouvelles databases sont lanc√©es :

- ü•≠ü•≠ü•≠ MongoDB
- üéâüéâüéâ Neo4j

Tadaaah !


#### Pourquoi √† ce moment-l√† ?

L'essor du world wide web (myspace üòç, youtube - 2005) et l'augmentation massive de l'√©chelle des applications de plusieurs ordres de grandeur.

Soudainement, nous avons des millions de personnes qui tentent simultan√©ment d'acc√©der et de modifier des Terabytes de donn√©es en quelques millisecondes.

Les databases relationnelles ne peuvent pas suivre l'√©chelle des applications, la nature chaotique des donn√©es non structur√©es et les exigences de vitesse.

La promesse du NoSQL est le **volume et la vitesse**.

### 2010s - Le NoSQL arrive √† maturit√© & Sp√©cialisation - Big Data et Databases Sp√©cialis√©es

- **Big Data Databases** : Des syst√®mes comme **Apache Hadoop** (2006) et **Apache Spark** (2009) ont permis le traitement de donn√©es √† tr√®s grande √©chelle.
- Les **Graph Databases** gagnent en popularit√© avec des cas d'usage comme la d√©tection de fraude, les knowledge graphs, et la gestion de la cha√Æne d'approvisionnement. Neo4j et Amazon Neptune deviennent des acteurs cl√©s.
- **Time-Series Databases (ex : InfluxDB, TimescaleDB)** : con√ßues pour les syst√®mes de monitoring : IoT, logs, ...
- **Cloud Databases** : services manag√©s comme Amazon **RDS**, Google **BigQuery**, ou **Snowflake**

et entre-temps, en 2013, les containers **Docker** r√©volutionnent le d√©ploiement des databases

### **2020s : IA, Vector Databases, et Besoins Temps R√©el**

- **Vector Databases** üå∂Ô∏èüå∂Ô∏èüå∂Ô∏è (ex : Pinecone, Weaviate, Qdrant, Milvus, Faiss, ...) :
  - G√®rent les vector embeddings de haute dimension utilis√©s dans les applications AI/ML

- et aussi :
  - üå∂Ô∏èüå∂Ô∏èüå∂Ô∏è **Graph + AI** : üå∂Ô∏èüå∂Ô∏èüå∂Ô∏è knowledge graphs et LLMs.
  - Multi-Model Databases qui supportent plusieurs mod√®les de donn√©es (document, graph, key-value) dans un seul syst√®me.
  - Real-Time Analytics : optimis√©s pour le streaming de donn√©es en temps r√©el et l'analytique.
  - Serverless Databases

### Tendances Actuelles (2024)

La vector search est en plein essor. Les capacit√©s de vector search sont int√©gr√©es dans la plupart des DBMS existants, y compris PostgreSQL, MongoDB et Neo4j.

![√©volution des databases](/img/epita-atabase-evolution-2024-11-21-062329.png)

### En Bref

- 1989 : Lancement de PostgreSQL
- 2009 : Lancement de MongoDB et Neo4j
- 2024 : les vector databases sont en vogue tandis que les databases plus anciennes int√®grent la vector search

## Cat√©gories principales de databases aujourd'hui

Nous avons de nombreuses databases parmi lesquelles choisir. Tout d√©pend de l'√©chelle, de la nature de l'application, du budget, etc.

| Type de Database          | Objectif                                   | Exemples                  | Application                                |
| ------------------------- | ------------------------------------------ | ------------------------- | ------------------------------------------ |
| **Relational - SQL**      | Schema fixe                                | PostgreSQL, MySQL, Oracle | Transactions, normalisation                |
| **Document Stores**       | Schema flexible, documents type JSON       | MongoDB, CouchDB          | Applications web, gestion de contenu       |
| **Graph Databases**       | Donn√©es centr√©es sur les relations         | Neo4j, ArangoDB           | R√©seaux sociaux, moteurs de recommandation |
| **Key-Value Stores**      | Recherches simples et rapides              | Redis, DynamoDB           | Caching, gestion des sessions              |
| **Vector Databases**      | Recherche par similarit√©, AI embeddings    | Pinecone, Weaviate        | Applications IA, recherche s√©mantique      |
| **Column-Family Stores**  | Donn√©es colonnes larges, haute scalabilit√© | Cassandra, HBase          | Time-series, applications big data         |
| **Time-Series Databases** | Donn√©es ordonn√©es dans le temps            | InfluxDB, TimescaleDB     | IoT, syst√®mes de monitoring                |


### √âcosyst√®me

Consultez le classement de toutes les databases sur <https://db-engines.com/en/ranking>

Les tendances : <https://db-engines.com/en/ranking_trend>

![tendances des databases](./../img/databases-trends.png)

De tr√®s nombreux acteurs :

![Carte du march√© des Databases 2024](./../img/Database-Market-Map-1.png)

source : <https://www.generativevalue.com/p/a-primer-on-databases>

Prenons du recul et comparons une database relationnelle SQL et une database NoSQL.

## SQL

Une database relationnelle :

- utilise un **schema** pr√©d√©fini : la structure des donn√©es (colonnes, types de donn√©es, etc.) est fixe.
- est excellente pour les queries complexes, les transactions et assurer la coh√©rence des donn√©es (conformit√© ACID).

Une **database relationnelle** peut √™tre compar√©e √† une collection de spreadsheets bien organis√©s (tables) o√π chaque colonne est d√©finie, et les feuilles sont interconnect√©es.

Les tables ont des colonnes et des lignes de donn√©es. Chaque table a une cl√© unique appel√©e **primary key**.

La conception du schema concerne la (d√©)normalisation. D√©cider o√π une information doit r√©sider de mani√®re unique ou non.

> Concept important de **Normalisation** : une information n'existe qu'√† un seul endroit et un seul.

### Hi√©rarchie d'une Database SQL :

- Une **foreign key** lie une table √† une autre table
- Une **row** contient la valeur d'une _entity_
- Une **column** est un **attribute** ou une propri√©t√© de l'_entity_
- Une **table** contient toutes les entities regroup√©es dans une structure fixe de colonnes

Les databases SQL = rigides, contr√¥l√©es, donn√©es coh√©rentes, stables, mais peuvent √™tre complexes.

## NoSQL

Une **database non-relationnelle** est un syst√®me de dossiers flexible o√π vous pouvez stocker des √©l√©ments de diff√©rentes formes sans r√®gles strictes.

- **schema flexible** avec donn√©es non structur√©es ou semi-structur√©es
- id√©al pour la haute scalabilit√© et la gestion de charges de travail massives et **distribu√©es**.

Pensez aux documents (JSON) plut√¥t qu'aux tables.

- Une **collection** est un ensemble de **documents**.
- Un document est une combinaison de keys : values.
- Chaque collection a une cl√© unique (le champ _id)
- Dans un document, vous pouvez avoir des subdocuments imbriqu√©s. Une personne peut avoir plusieurs t√©l√©phones, adresses email, emplois, ...

Tous les documents d'une collection sont **similaires en structure** mais n'ont pas besoin d'√™tre exactement identiques.

Il n'y a pas de concept de normalisation.

### Hi√©rarchie de MongoDB - Database NoSQL - MongoDB

- Une **database** contient des **Collections**
- Une **collection** contient tous les **documents**
- Un **document** est l'entity ou la valeur de donn√©es
- Un subdocument (imbriqu√©) est un document **√† l'int√©rieur** d'un document parent
- Un **field** est un attribute ou une propri√©t√© du document

Les databases NoSQL = fluides, adaptatives, flexibles.

### Terminologie

MongoDB - SQL :

- Un `document` est un record, une row
- Une `Collection` est une table
- Un `Field` est une Column

| MongoDB           | SQL Database |
| ----------------- | ------------ |
| Database          | Database     |
| Collection        | Table        |
| Document          | Record/Row   |
| Field             | Column       |
| Embedded Document | Foreign Key  |
| `_id`             | Primary Key  |
| `$lookup`         | JOIN         |

Un `index` reste un `index`


## Schema-less ou schema dynamique

Dans quelles situations les donn√©es sont-elles si dynamiques qu'il nous faut un type sp√©cial de databases ?

L'exemple le plus courant d'application NoSQL est celui d'un r√©seau social.

- profils utilisateurs
- les posts contiennent toutes sortes de contenu
- timeline, followers, etc

### Yuka et les produits alimentaires

Prenons l'exemple d'une start-up comme [Yuka](https://yuka.io/en/)

![Yuka](./../img/yuka-screenshot.png)

Selon leurs propres mots : _Yuka d√©chiffre les √©tiquettes des produits et analyse l'impact sur la sant√© des produits alimentaires et cosm√©tiques._

Sa database sous-jacente est la [open food facts database](https://world.openfoodfacts.org/), une database de produits alimentaires faite par tous, pour tous, avec plus de 3,5 millions de produits alimentaires.

Regardez par exemple les informations pour [Nutella](https://uk.openfoodfacts.org/product/3017620422003/nutella) et celles pour... [Baguette](https://world.openfoodfacts.org/product/3250393046940/baguette-constance-cereales-250g-la-campaniere)

Voir aussi cet article qui explore le dataset avec python pandas : https://medium.com/@achrafelkhanjari99/a-deep-dive-into-the-open-food-facts-dataset-56259b162ac5 (disponible en pdf sur le repo Github)

Avec autant de produits, les informations disponibles et les informations associ√©es (Packaging, Impact Carbone) ainsi que la diversit√© des r√©glementations (UE, US, UK, ... etc) varient constamment.

Les donn√©es sont constamment mises √† jour tout en gardant l'historique des changements et des nouveaut√©s.

- de nouvelles donn√©es deviennent disponibles au fur et √† mesure que les acteurs mettent en place la collecte de donn√©es. Pensez tra√ßabilit√©, s√©curit√©, etc
- les nouvelles r√©glementations imposent plus de donn√©es
- l'actualit√©, les tendances sociales et les centres d'int√©r√™t changent rapidement (sans gluten, thon et mercure, ...)

Vous commencez donc votre database avec un schema simple qui inclut :

- nom, d√©finition, image, description
- valeurs nutritionnelles
- ingr√©dients

Mais le schema devient de plus en plus complexe √† mesure que les donn√©es et les produits et services de l'entreprise √©voluent.

#### Nutriscore

Prenons par exemple le label Nutriscore :

<img src="./../img/nutri-score-f_1200x800.jpg" width='50%' style='display: block; margin: auto; padding-bottom: 30px;' alt= "Nutriscore">

Le [Nutriscore](https://nutriscore.blog/2022/08/04/report-of-the-european-scientific-committee-in-charge-of-updating-the-nutri-score-changes-to-the-algorithm-for-solid-foods/) a r√©cemment √©volu√© avec une nouvelle version plus stricte. Vous avez besoin des nouveaux labels Nutriscore tout en gardant l'ancien car tous les produits n'impl√©mentent pas le nouveau Nutriscore. Certaines entreprises ont m√™me compl√®tement abandonn√© l'√©tiquetage.

Vous avez commenc√© avec une table Nutriscore dans une database SQL :

```sql
product_id: key
nutriscore_label : array[A,B, .., E]
```

donc votre table Nutriscore n√©cessite une nouvelle colonne :

```sql
product_id: key
nutriscore_label: array[A,B, .., E]
nutriscore_new_label: array[A,B, .., E]
```

Cependant, la plupart des produits n'ont pas encore de nouveau label nutriscore.

Et vous vous retrouvez avec beaucoup de null values dans cette colonne `nutriscore_new_label` et les null values sont diaboliques üëπüëπüëπ.

![NULL values headache](./../img/memes/null-values-headache.png)

Vous pouvez aussi normaliser la table et introduire une colonne version du Nutriscore pour aider avec les Null values.

```sql
product_id: key
nutriscore_label: array[A,B, .., E]
nutriscore_version: Int
```

Dans les deux cas, vous devez changer toutes vos SQL queries dans votre code base.

Grosse douleur, gros tracas, maux de t√™te, bugs cach√©s et co√ªts suppl√©mentaires ÔºÑÔºÑÔºÑ.

## Introduction √† la Schema Flexibility

La **Schema Flexibility** dans MongoDB et d'autres databases NoSQL fait r√©f√©rence √† la capacit√© de stocker des donn√©es sans n√©cessiter un schema pr√©d√©fini. Cela signifie que les documents d'une m√™me collection peuvent avoir diff√©rents fields, structures et types de donn√©es.

La Schema Flexibility aide √† g√©rer les **unknown unknowns** dans un monde qui change rapidement.

### Pr√©sence et type de donn√©es

Dans MongoDB : Vous pouvez simplement ajouter un nouvel √©l√©ment Nutriscore aux produits alimentaires :

Pas de Nutriscore

```json
{
  "product_id": 198273,
  "name": "Corn Flakes Cereals",
}
```

Le Nutriscore est ajout√©, il suffit d'ajouter un field au document du produit

```json
{
  "product_id": 198273,
  "name": "Corn Flakes Cereals",
  "Nutriscore": "C"
}
```

Une nouvelle version du Nutriscore arrive, il suffit d'ajouter le label Nutriscore comme un dictionary avec les versions comme keys :

```json
{
  "product_id": 198273,
  "name": "Corn Flakes Cereals",
  "Nutriscore": {
    "v1": C,
    "v2": D,
  }
}
```

Plusieurs repr√©sentations peuvent **coexister** dans la m√™me database :

- Pas de nutriscore
- Un seul nutriscore comme string
- Un dictionary nutriscore comme document nested / embedded

### Donn√©es Nested / Complexes

- SQL n√©cessite une normalisation en plusieurs tables pour les structures complexes
- MongoDB peut naturellement **nested** les donn√©es li√©es

Un autre exemple est celui de l'adresse d'une personne

```json
// Une personne sans adresse enregistr√©e
{
    "_id": "1",
    "name": "Anita Sharma",
    "age": 29,
    "email": "anita.sharma@example.com"
}

// Une personne avec une seule adresse comme dictionary
{
    "_id": "2",
    "name": "Rahul Verma",
    "age": 42,
    "email": "rahul.verma@example.com",
    "addresses": {
        "type": "home",
        "street": "12 MG Road",
        "locality": "Indiranagar",
        "city": "Bengaluru",
        "state": "Karnataka",
        "pincode": "560038",
        "country": "India"
    }
}

// Une personne avec plusieurs adresses comme liste de dictionaries
{
    "_id": "3",
    "name": "Priya Singh",
    "age": 35,
    "email": "priya.singh@example.com",
    "addresses": [
        {
            "type": "home",
            "street": "45/2 Lajpat Nagar",
            "locality": "Central Market",
            "city": "New Delhi",
            "state": "Delhi",
            "pincode": "110024",
            "country": "India"
        },
        {
            "type": "work",
            "street": "4th Floor, Tower B",
            "locality": "DLF Cyber City",
            "city": "Gurugram",
            "state": "Haryana",
            "pincode": "122002",
            "country": "India"
        }
    ]
}
```

### Cons√©quences de la schema flexibility

La Schema Flexibility impacte chaque √©tape du cycle de vie d'une database

- **Design** : sans r√®gles claires, tout devient possible. Les choix de conception sont dict√©s par l'application. La fa√ßon dont les donn√©es sont _consomm√©es_ dicte la structure des donn√©es dans la database.
- **Development** : avec un schema flexible, les changements peuvent √™tre impl√©ment√©s plus rapidement.
- **Maintenance** : l'inconv√©nient est la n√©cessit√© de g√©rer l'organisation et les types de donn√©es plus anciens

Une prudence suppl√©mentaire est n√©cessaire pour √©viter le chaos et les **data inconsistencies**. La performance des queries peut √™tre affect√©e si les changements dans la structure des donn√©es conduisent √† un indexing inefficace ou incoh√©rent.

Avec les databases NoSQL, le co√ªt de l'impl√©mentation des changements dans la nature des donn√©es est d√©plac√© de la database vers le niveau applicatif.

Cependant, des inconsistencies dans la database peuvent toujours survenir si plusieurs applications interagissent diff√©remment avec la m√™me database.

> En bref, la schema flexibility doit √™tre utilis√©e avec pr√©caution et uniquement lorsque c'est utile et justifi√©.

## Quand choisir NoSQL (document database) plut√¥t que SQL ?

Alors quand est-ce qu'une Document database NoSQL est un meilleur choix que SQL ?

- Vos donn√©es correspondent naturellement √† une structure de **document** plut√¥t qu'√† des tables strictes
  - Vous voulez stocker les donn√©es li√©es ensemble plut√¥t que de les r√©partir dans des tables pour acc√©l√©rer la r√©cup√©ration d'information. queries plus simples, moins de joins, moins de complexit√© de code.

- It√©ration Rapide : Votre schema doit √©voluer rapidement et vous privil√©giez la vitesse de d√©veloppement √† la stricte coh√©rence des donn√©es
  - Applications et exigences de donn√©es qui changent rapidement
  - Startups en phase initiale o√π le mod√®le de donn√©es n'est pas encore pleinement compris

- √©galement : A/B testing de diff√©rentes fonctionnalit√©s qui peuvent n√©cessiter diff√©rentes structures de donn√©es

- Scalabilit√© et Performance
  - Con√ßu pour le **horizontal scaling** avec support int√©gr√© du **sharding** (distribution des donn√©es sur plusieurs serveurs).
  - Adapt√© √† la gestion d'applications √† grande √©chelle, haut d√©bit et g√©ographiquement distribu√©es.

MongoDB scale out, tandis que PostgreSQL scale up.

- Utilise un mod√®le de document flexible de type JSON (BSON), le rendant id√©al pour les donn√©es hi√©rarchiques ou semi-structur√©es.
  - R√©duit le besoin de joins complexes, car les donn√©es li√©es peuvent √™tre embedded dans un seul document.

MongoDB excelle dans :

- Les applications avec des donn√©es non structur√©es ou semi-structur√©es.
- Les charges de travail √† haute v√©locit√© n√©cessitant des changements rapides de schema.
- Les cas d'utilisation n√©cessitant un horizontal scaling dans des environnements distribu√©s.

### Performance

En termes de performance, la comparaison favorise la plupart du temps PostgreSQL par rapport √† MongoDB.
voir [MongoDB Vs PostgreSQL: A comparative study on performance aspects](https://link.springer.com/article/10.1007/s10707-020-00407-w)

Et cet autre article, [MongoDB vs PostgreSQL: Choosing the Best Database for Your Needs](https://www.halfnine.com/blog/post/mongodb-vs-postgresql), le r√©sume bien :

> _MongoDB brille dans les sc√©narios n√©cessitant le d√©veloppement d'applications logicielles qui traitent divers types de donn√©es de mani√®re √©volutive. Il est particuli√®rement adapt√© aux projets qui doivent supporter un d√©veloppement it√©ratif rapide et faciliter la collaboration de nombreuses √©quipes.

Dans [Postgres vs. MongoDB: a Complete Comparison in 2024](https://www.bytebase.com/blog/postgres-vs-mongodb/)

### En bref

- Choisissez MongoDB si votre application a un mod√®le de donn√©es simple et g√®re des donn√©es √† l'√©chelle du web.
- Choisissez PostgreSQL si votre application a une logique m√©tier complexe et n√©cessite des requ√™tes complexes.

## Qu'en est-il des bases de donn√©es graphes ?

Les bases de donn√©es SQL sont appel√©es bases de donn√©es relationnelles.

Dans une base de donn√©es SQL, la relation entre les tables est explicitement d√©finie par des cl√©s √©trang√®res.

- Product -> Vegetables -> Location, Origin
- Product -> Vegetables -> Organic / not Bio
- Product -> nutrition (sugar, fat etc)
- Product -> Nutriscore labels
- Product -> ConsumeBy

Et l'ERD pour une telle base de donn√©es indique uniquement la cardinalit√© de la relation :

- 1 to 1
- 1 to many

![ERD](./../img/ERD_v03.png)

Quand vous demandez √† un LLM de g√©n√©rer un diagramme pour une base de donn√©es de produits, il ajoute naturellement des informations significatives aux relations entre les tables.

![product veggies schema relation](/img/product-veggies-schema-relation.png)
[Mermaid](https://mermaid.live) diagram

### Relationships

Les bases de donn√©es graphes sont centr√©es sur la _signification_ des **relations** entre entit√©s.

> Dans les bases de donn√©es graphes comme Neo4j, les **relations** sont aussi importantes que les donn√©es elles-m√™mes et sont stock√©es explicitement.

Ces relations ont leurs propres propri√©t√©s et sont stock√©es comme des connexions.

Alors qu'en SQL :

- Les relations sont implicites via des cl√©s √©trang√®res
- Doivent √™tre reconstruites via des JOINs
- Deviennent exponentiellement plus complexes et lentes lorsque vous suivez plusieurs niveaux de connexions

C'est pourquoi Neo4j excelle dans les questions comme :

- "Trouvez tous les amis d'amis qui aiment courir et vivent √† Paris"
- "Quel est le chemin le plus court entre la personne A et la personne B ?"
- "Qui sont les personnes les plus influentes dans ce r√©seau ?"

Voici un exemple de graphe de connaissances avec Obsidian

<img src="./../img/obsidian.jpeg" width='90%' style='display: block; margin: auto; ' alt= "Obsidian Knowledge Graph">

Nous reviendrons sur Neo4j dans 2 semaines.

## conclusion

Donc les bases de donn√©es SQL, dites relationnelles, sont excellentes pour les structures de donn√©es qui ne changent pas souvent et o√π les relations entre objets sont stables.

Les bases de donn√©es No-SQL comme MongoDB : excellentes quand les sp√©cifications des donn√©es √©voluent rapidement ou ne sont pas d√©finitives, sch√©ma flexible, grande √©chelle

Bases de donn√©es graphes : la relation est cl√©. Ce n'est pas seulement qu'il y a une relation mais aussi quelle est la nature de cette relation.

- NoSQL - Document concerne l'√©volutivit√© et l'√©volution des donn√©es.
- Graph concerne la r√©ponse √† des questions sp√©cifiques, la d√©couverte de diff√©rents types de signification et d'aper√ßus dans les donn√©es.

Dans cette session, vous avez appris :

- DBMS et l'histoire des bases de donn√©es
- Un aper√ßu des diff√©rents types de bases de donn√©es
- Base de donn√©es relationnelle vs non relationnelle
- Sch√©ma flexible dans les bases de donn√©es NoSQL

- Pourquoi et quand choisir MongoDB plut√¥t que SQL
