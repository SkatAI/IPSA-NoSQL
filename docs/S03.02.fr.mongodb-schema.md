# S03.02 Design patterns


## Schema Design

Le design du sch√©ma MongoDB est la partie la plus critique de la concception d'une base de donn√©es qui puisse √©voluer et qui soit rapide avec des co√ªts maitris√©s.

Si vous concevez le sch√©ma MongoDB comme un sch√©ma relationnel, vous perdez de vue les avantages et la puissance de NoSQL.

Conception du sch√©ma MongoDB¬†: meilleures pratiques de mod√©lisation des donn√©es

https://www.mongodb.com/developer/products/mongodb/mongodb-schema-design-best-practices/


Si la question est : comment mod√©liser mes donn√©es pour une utilisationavec une bdd MongoDB ?


La r√©ponse est :

> Cela d√©pend. En effet, les bases de donn√©es documentaires ont un vocabulaire riche qui est capable d'exprimer les relations de donn√©es de mani√®re plus nuanc√©e que SQL. Il y a beaucoup de choses √† consid√©rer lors du choix d'un sch√©ma.
> - Votre application est-elle lourde en lecture ou en √©criture¬†?
> - Quelles donn√©es sont fr√©quemment consult√©es ensemble¬†?
> - Quelles sont vos consid√©rations en mati√®re de performances¬†?
> - Comment vos donn√©es va-t-il cro√Ætre et √©voluer¬†?

Dans les bases de donn√©es SQL, la **normalisation** consiste √† r√©partir les donn√©es en tables, afin de ne pas les dupliquer. (c'est un r√©sum√© rapide de ce qu'est la normalisation)

- 1 utilisateur
- a plusieurs moyens de transport -> v√©lo, voiture, ..., jet priv√©
- a un emploi
- a une addresse
- a effectu√© plusieurs visites sur un site

En sql : tables multiples, appliquer les formes de normalisation, etc.

Avec MongoDB, il n'y a¬†:

- ni de processus formel
- ni d'algorithmes
- ni de r√®gles

C'est qui n'est absolument pas flippant¬†!!! üò≥üò≥üò≥

Ce qui compte, c'est de concevoir un sch√©ma qui fonctionne au mieux **pour l'application finale**. Deux applications diff√©rentes qui utilisent exactement les m√™mes donn√©es peuvent avoir des sch√©mas tr√®s diff√©rents si les donn√©es sont utilis√©es diff√©remment.

üê≤üê≤üê≤ **L'application dicte le sch√©ma¬†!**

### R√©f√©rencement vs int√©gration (embedding)


On compare les 2 approches suivantes:

- R√©f√©rencement: le document a une r√©f√©rence vers un autre document

```json
// user collection
{
    "_id": "some user_id",
    "name": "Bart",
    "school": "Springfied elementary"
}

// transportation collection
{
    "_id": "some _id",
    "user_id": "user_id",
    "type": "bike",
    "avg_speed": "15kph",
},
{
    "_id": "some _id",
    "user_id": "user_id",
    "type": "jet fighter",
    "avg_speed": "1500kph",
}

```


- int√©gration / imbrication (embedding): le sous document fait partie du document principal


```json
// user collection
{
    "_id": "some user_id",
    "name": "Bart",
    "school": "Springfied elementary",
    "transportation": [
        {
            "type": "bike",
            "avg_speed": "15kph",
        },
        {
            "type": "jet fighter",
            "avg_speed": "1500kph",
        }
    ]
}

```

#### Avantages de l'int√©gration / Embedding

- On r√©cup√®re toutes les informations en une seule requ√™te.
- on √©vite les jointures
- une seule op√©ration pour la mise a jour des donn√©es imbriqu√©es.


Pour les transactions¬†:

- Par d√©faut, toutes les op√©rations CRUD sur un seul document sont conformes √† ACID.
- Pour les transactions qui comprennent plusieurs op√©rations, on peut utiliser l'op√©rateur de transaction.

#### Limitations de l'int√©gration

- La taille des documents impact negativement la performance des requetes. Il faut faire attention a ne pas tout mettre dans un document, mais restreindre aux informations pertinentes. Limiter la taille des documents permet d'am√©liorer la performance des requetes.

- Les documents de MongoDB sont limit√©s √† une taille de **16¬†Mo**.

Il y a donc un √©quilibre √† trouver entre exhaustivit√© des informations et taille des documents

### R√©f√©rencement

L'autre option pour concevoir le sch√©ma est de r√©f√©rencer un autre document √† l'aide de l'ID d'objet unique d'un document et de les connecter √† l'aide de l'op√©rateur `$lookup`.

Le r√©f√©rencement fonctionne de la m√™me mani√®re que l'op√©rateur `JOIN` dans une requ√™te SQL. Il permet de r√©partir les donn√©es pour effectuer des requ√™tes plus efficaces et plus √©volutives, tout en maintenant les relations entre les donn√©es.

#### Avantages du r√©f√©rencement

- En r√©partissant les donn√©es, on obtient des documents plus petits et donc moins susceptibles d'atteindre la limite de 16¬†Mo par document.
- Certaines donn√©es ne sont pas consult√©es aussi fr√©quemment que d'autres donn√©es. Il est donc logique de les s√©parer des donn√©es principales.
- Le r√©f√©rencement r√©duit la duplication des donn√©es.

#### Limitations du r√©f√©rencement

- Afin de r√©cup√©rer toutes les donn√©es dans les documents r√©f√©renc√©s, un minimum de deux requ√™tes ou `$lookup` est n√©cessaire pour r√©cup√©rer toutes les informations. MongoDB est moins efficace pour les jointures qu'une base de donn√©es SQL.

## Conception du sch√©ma et nature des relations

Il faut tenir compte de la nature des relations entre les entit√©s

#### Un-√†-un (one to one)

Mod√©lis√© sous forme de paires cl√©-valeur dans la base de donn√©es.


Par exemple :

- train <-> nombre de passagers
- utilisateur <-> date de naissance
- arbre <-> vari√©t√©
- humain <-> taille

#### Un-√†-quelqu'uns (one to few)

Une petite s√©quence de donn√©es associ√©e √† l'entit√© principale.

- une personne a quelques adresses (1, 2, ... 5)
- une playlist a quelques morceaux
- une recette a quelques ingr√©dients
- un Parisien a quelques caf√©s pr√©f√©r√©s

#### Un-√†-plusieurs (one to many)

- une salle de sport a plusieurs utilisateurs
- un produit a plusieurs pi√®ces
- une ligne de bus a plusieurs arr√™ts
- votre instagram a plusieurs followers

#### Un-√†-beaucoup (one to squillions)

C'est le cas ou on a potentiellement des millions de sous-documents

- universit√© <-> des milliers d'√©tudiants
- compte insta d'un(e) people <-> des millions de followers
- serveur <-> log events


##### Example de sch√©ma pour un server + log

Une application de journalisation de serveur (server log). Chaque serveur enregistre une quantit√© importante d'ev√®nement.
On a donc 2 entit√©s: server et event.

3 options

- le document server int√®gre les events associ√©es au server. (forte probablilit√© que cela depasse les 16 Mb par document assez rapidement)
- separer les 2 collections et faire un @lookup. Plus lent pour r√©cuperer tous les evenements d'un serveur
- inserer le nom du serveur dans chaque document event! duplication des donn√©es mais rapidit√© de requetage et pas de risque de d√©passer la taille de 16Mb


#### Plusieurs-√†-plusieurs (many to many)

Exemple d'une application de planification de projet¬†:

- un utilisateur peut avoir plusieurs t√¢ches
- une t√¢che peut avoir plusieurs utilisateurs assign√©s.

Un sch√©ma efficace consiste √† stocker

- l'ID des utilisateurs dans le document de t√¢che
- l'ID des t√¢ches dans le document utilisateur.

Utilisateurs¬†:

```json
{
    "_id": ObjectID("AAF1"),
    "name": "Kate Monster",
    "tasks": [ObjectID("ADF9"), ObjectID("AE02"), ObjectID("AE73")]
}
```

T√¢ches¬†:

```json
{
  "_id": ObjectID("ADF9"),
  "description": "√âcrire un billet de blog sur la conception de sch√©mas MongoDB",
  "due_date": ISODate("2014-04-01"),
  "owners": [ObjectID("AAF1"), ObjectID("BB3G")]
}
```

Dans cet exemple, vous pouvez voir que chaque utilisateur a un sous-tableau de t√¢ches li√©es, et que chaque t√¢che a un sous-tableau de propri√©taires pour chaque √©l√©ment de notre application de t√¢ches.

### R√©capitulatif¬†:

- **Un-√†-un** - Pr√©f√©rez les paires cl√©-valeur dans le document
- **Un-√†-quelques-uns** - Pr√©f√©rez l'int√©gration
- **Un-√†-plusieurs** - Pr√©f√©rez l'int√©gration
- **Un-√†-des-squillions** - Pr√©f√©rez le r√©f√©rencement
- **Plusieurs-√†-plusieurs** - Pr√©f√©rez le r√©f√©rencement crois√©

R√®gles g√©n√©rales pour la conception de sch√©mas MongoDB¬†:

- R√®gle¬†1¬†: privil√©giez l'int√©gration, sauf s'il existe une bonne raison  de ne pas le faire.
- R√®gle¬†2¬†: la n√©cessit√© d'acc√©der √† un objet de fa√ßon ind√©pendante est une bonne raison  de ne pas l'int√©grer.
- R√®gle¬†3¬†: √©vitez les jointures et les recherches si possible, mais n'ayez pas peur si elles peuvent fournir une meilleure conception de sch√©ma.
- R√®gle¬†4¬†: les tableaux ne doivent pas cro√Ætre sans limite. Lorsqu'il y a plus de quelques centaines de documents imbriqu√©s, il vaut mieux les r√©f√©rencer; De m√™me, Lorsqu'il y a plus de quelques milliers de documents imbriqu√©s, n'utilisez pas de tableau de r√©f√©rences par ID. Enfin les tableaux √† forte cardinalit√© (nombreuse valeurs potentielles) sont une bonne raison de ne pas int√©grer.
- R√®gle¬†5¬†: comme toujours, avec MongoDB, la fa√ßon dont vous mod√©lisez vos donn√©es d√©pend enti√®rement des mod√®les d'acc√®s aux donn√©es de votre application. Vous souhaitez structurer vos donn√©es pour qu'elles correspondent √† la mani√®re dont votre application les interroge et les met √† jour.


## Mod√®les de Schema design
Examinons 2 mod√®les de Schema design pour illustrer la flexibilit√© et la mani√®re dont l'application dicte la conception du sch√©ma de donn√©es.

### Mod√®le de r√©f√©rence √©tendu

Passons en revue cet article

https://www.mongodb.com/developer/products/mongodb/schema-design-anti-pattern-massive-arrays/

> L'une des r√®gles empiriques lors de la mod√©lisation des donn√©es dans MongoDB consiste a dire que les donn√©es auxquelles on acc√®de en m√™me temps doivent √™tre stock√©es ensemble.

-> Un b√¢timent a de nombreux employ√©s¬†: potentiellement trop pour la limite de document de 16¬†Mo.

On inverse la situation avec

-> L'employ√© appartient √† un b√¢timent¬†: on int√®gre les informations du b√¢timent dans le document de l'employ√©.

> Si l'application affiche fr√©quemment des informations sur un employ√© et son b√¢timent ensemble, ce mod√®le est probablement judicieux.

Probl√®me¬†: on a beaucoup trop de duplication de donn√©es.

La mise √† jour des informations d'un b√¢timent¬†implique de  mettre √† jour tous les documents d'employ√©s.

Alors, s√©parons les employ√©s et le b√¢timent en 2 collections distinctes et utilisons des `$lookups`.

Mais les `$lookups` sont co√ªteux.

Nous utilisons donc le [mod√®le de r√©f√©rence √©tendu](https://www.mongodb.com/blog/post/building-with-patterns-the-extended-reference-pattern) (extended reference pattern)  o√π on duplique certaines, mais pas toutes, des donn√©es dans les deux collections. On ne duplique que les donn√©es qui sont fr√©quemment consult√©es ensemble.

> Par exemple, si l'application poss√®de une page de profil utilisateur qui affiche des informations sur l'utilisateur ainsi que le nom du b√¢timent et la r√©gion o√π il / elle travaille, on int√©gre le nom du b√¢timent et la r√©gion dans le document de l'employ√© mais les autres infos li√©es au b√¢timent.

### Le mod√®le des valeurs aberrantes (outlier pattern)

Le mod√®le des valeurs outliers:  seuls quelques documents poss√®dent une quantit√© √©norme de documents imbriqu√©s.

https://www.mongodb.com/blog/post/building-with-patterns-the-outlier-pattern

Consid√©rez une collection de livres et la liste des utilisateurs qui ont achet√© le livre.

```json
{
    "_id": ObjectID("507f1f77bcf86cd799439011")
    "title": "Une histoire ennuyeuse",
    "author": "Sam K. Boring",
    ‚Ä¶,
    "customers_purchased": ["user00", "user01", "user02"]

}
```

La plupart des livres ne se vendent qu'√† quelques exemplaires. C'est la longue tra√Æne (long tail) des ventes de livres.

Pour la plupart des livres on peut simplement int√©grer la liste des acheteurs  (ID et quelques infos pertinentes) dans le document du livre.

Une faible quantit√© de livres se vendent √† des millions d'exemplaires. Impossible d'imbriquer les acheteurs dans le doc du livre.

En ajoutant un champ, un flag, ou indicateur, qui signale que le livre est tres populaire, on peut adapter le schema en fonction de cette indicateur.


```json
{
    "_id": ObjectID("507f191e810c19729de860ea"),
    "title": "Harry Potter",
    "author": "J.K. Rowling",
    ‚Ä¶,
    // on evite d'integrer les acheteurs pour ce livre
    //    "customers_purchased": ["user00", "user01", "user02", ‚Ä¶, "user9999"],
   "outlier": "true"
}
```

Dans le code de l'application, nous testons la pr√©sence de cet indicateur et traitons les donn√©es diff√©remment si l'indicateur est pr√©sent.
Par exemple en referencant les acheteurs des livres tres populaires au lieu de les imbriquer.

Le mod√®le des valeurs aberrantes est fr√©quemment utilis√© dans les situations o√π la popularit√© est un facteur, comme dans les relations sur les r√©seaux sociaux, les ventes de livres, les critiques de films,

## D√©finition et validation du sch√©ma

Sans validation explicite il est possible de mttre n'importe quoi dans une collection.

Par exemple, l'age de l'utilisateur

- 32 (int)
- "32" (string)
- trente-deux
- 432
- null
- ""

etc etc.

L'absence de validation quant aux valeurs acceptables dans une collection repousse la complexit√© au niveau applicatif.

C'est le chaos!

### Application d'un type de donn√©es

D√©clarer le type de donn√©es lors de la d√©finition du sch√©ma

```bash
db.createCollection("movies", {
    validator: {
        $jsonSchema: {
            bsonType: "object",
            required: ["year", "title"],  // Champs qui doivent √™tre pr√©sents
            properties: {
                year: {
                    bsonType: "int",  // Force que `year` soit un entier
                    required: "true",
                    description: "Doit √™tre un entier et est obligatoire"
                },
                title: {
                    bsonType: "string",
                    description: "Titre du film, doit √™tre une cha√Æne de caract√®res si pr√©sent"
                },
                imdb: {
                    bsonType: "object",  // Objet imbriqu√© pour les donn√©es IMDb
                    properties: {
                        rating: {
                            bsonType: "double",  // La note IMDb doit √™tre un float
                            description: "Doit √™tre un float si pr√©sent"
                        }
                    }
                }
            }
        }
    }
})
```

Points cl√©s¬†:

- **bsonType**: sp√©cifie le type de donn√©es BSON pour le champ (par exemple, int, string, array, object).
- **required**: garantit que des champs sp√©cifiques sont obligatoires.
- **properties**: d√©finit les contraintes pour chaque champ.
- **description**: ajoute une description utile pour les erreurs de validation.

MongoDB prend en charge la validation de sch√©ma √† partir de la version¬†3.6, ce qui vous permet d'appliquer des types de donn√©es et d'autres contraintes sur les champs au sein d'une collection. Ceci est r√©alis√© √† l'aide de la fonctionnalit√© de validation `$jsonSchema` lors de la cr√©ation ou de la mise √† jour d'une collection.

<https://www.digitalocean.com/community/tutorials/how-to-use-schema-validation-in-mongodb>

Lorsque vous ajoutez des r√®gles de validation √† une collection existante, les nouvelles r√®gles n'affecteront pas les documents existants tant que vous n'essayez pas de les modifier.

## Pratique

Petit exemple sur les jeux de donn√©es d'arbres¬†

```json
{
        "idbase":249403,
        "location_type":"Arbre",
        "domain":"Alignement",
        "arrondissement":"PARIS 20E ARRDT",
        "suppl_address":"54",
        "number":null,
        "address":"AVENUE GAMBETTA",
        "id_location":"1402008",
        "name":"Tilleul",
        "genre":"Tilia",
        "species":"tomentosa",
        "variety":null,
        "circumference":85,
        "height":10,
        "stage":"Adulte",
        "remarkable":"NON",
        "geo_point_2d":"48.86685102642415, 2.400262189227641"
    },
```

√©crire un sch√©ma et un validateur pour ces donn√©es

le validateur doit appliquer

- height >= 0 et <100
- stage ['']

## pratique

prenez une version json du jeux de donn√©es trees o√π les colonnes avec des valeurs null ont √©t√© supprim√©es

1. r√®gles de libert√©
   - ins√©rer toutes les donn√©es sans validation
   - requ√™te pour v√©rifier les valeurs absurdes¬†: height, geolocation
2. approche plus contr√¥l√©e
   - √©crire un sch√©ma et un validateur¬†: en utilisant le validateur $jsonSchema de MongoDB pour ¬´¬†ex√©cuter √† blanc¬†¬ª votre validation de donn√©es.
   - v√©rifier le nombre de documents ignor√©s
   - √©crire un validateur qui r√©cup√®re le plus de documents possible tout en excluant les valeurs absurdes
3. index
   - ajouter un index unique sur la g√©olocalisation

dans MongoDB, le validateur de sch√©ma est g√©n√©ralement cr√©√© avec la collection, et non comme une √©tape distincte

## Conclusion

https://galaktika-soft.com/blog/sql-vs-nosql.html

Points √† consid√©rer¬†:

- Point de donn√©es unique ou grands volumes
- les pipelines d'agr√©gation sont plus lents que les requ√™tes SQL complexes
- lectures vs √©critures
- stockage et indexation
- Conformit√© ACID¬†: Mongodb assure ACID depuis la v4 https://www.mongodb.com/products/capabilities/transactions et voir https://www.mongodb.com/resources/products/capabilities/acid-compliance
- MongoDB √©volue horizontalement, SQL verticalement

et le facteur le plus important

- comment les donn√©es sont-elles consomm√©es par l'application

## Liens

Mod√®les de conception de sch√©ma¬†: https://learn.mongodb.com/courses/schema-design-patterns
